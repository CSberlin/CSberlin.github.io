<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>PAT乙级1031查验身份证</title>
    <url>/2021/02/01/pat%E4%B9%99%E7%BA%A71031/</url>
    <content><![CDATA[<ul>
<li><a href="#1-%E9%A2%98%E7%9B%AE">1. 题目</a><ul>
<li><a href="#11-%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F">1.1. 输入格式</a></li>
<li><a href="#12-%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B">1.2. 输出样例</a></li>
<li><a href="#13-%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B1">1.3. 输入样例1</a></li>
<li><a href="#14-%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B1">1.4. 输出样例1</a></li>
</ul>
</li>
<li><a href="#2-%E6%80%9D%E8%B7%AF">2. 思路</a></li>
<li><a href="#3-%E6%B3%A8%E6%84%8F">3. 注意</a></li>
<li><a href="#4-code">4. code</a></li>
</ul>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：<br>首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：  </p>
<p>Z：0 1 2 3 4 5 6 7 8 9 10<br>M：1 0 X 9 8 7 6 5 4 3 2</p>
<p>现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。</p>
<h2 id="1-1-输入格式"><a href="#1-1-输入格式" class="headerlink" title="1.1. 输入格式"></a>1.1. 输入格式</h2><p>输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。</p>
<h2 id="1-2-输出样例"><a href="#1-2-输出样例" class="headerlink" title="1.2. 输出样例"></a>1.2. 输出样例</h2><p>按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。</p>
<h2 id="1-3-输入样例1"><a href="#1-3-输入样例1" class="headerlink" title="1.3. 输入样例1"></a>1.3. 输入样例1</h2><p>4<br>320124198808240056<br>12010X198901011234<br>110108196711301866<br>37070419881216001X</p>
<h2 id="1-4-输出样例1"><a href="#1-4-输出样例1" class="headerlink" title="1.4. 输出样例1"></a>1.4. 输出样例1</h2><p>12010X198901011234<br>110108196711301866<br>37070419881216001X</p>
<h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h1><p>首先用int数组存权重，用string存校验码，如果身份证非纯数字则输出，如果身份证前17位权重%11不等于最后Z对应的M值则输出。若全部身份证符合要求，则输出All passed。</p>
<h1 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h1><ul>
<li>数字字符向数字的转换  数字字符-‘0’=数字</li>
</ul>
<h1 id="4-code"><a href="#4-code" class="headerlink" title="4. code"></a>4. code</h1><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> quan[<span class="number">17</span>] = {<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>};</span><br><span class="line">    string jiaoyan = <span class="string">"10X98765432"</span>;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N; i++)</span><br><span class="line">    {</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">17</span>;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(s[j]&lt;<span class="string">'0'</span>||s[j]&gt;<span class="string">'9'</span>) {cout&lt;&lt;s&lt;&lt;endl;flag=<span class="literal">true</span>;<span class="keyword">break</span>;}</span><br><span class="line">            sum += (s[j]-<span class="string">'0'</span>)*quan[j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>&amp;&amp;jiaoyan[sum%<span class="number">11</span>]!=s[<span class="number">17</span>]){cout&lt;&lt;s&lt;&lt;endl;flag=<span class="literal">true</span>;}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">"All passed"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1030完美数列</title>
    <url>/2021/01/25/pat%E4%B9%99%E7%BA%A71030/</url>
    <content><![CDATA[<ul>
<li><a href="#1-%E9%A2%98%E7%9B%AE">1. 题目</a></li>
<li><a href="#2-%E6%80%9D%E8%B7%AF">2. 思路</a></li>
<li><a href="#3-%E6%B3%A8%E6%84%8F">3. 注意</a></li>
<li><a href="#4-code">4. code</a></li>
</ul>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M &lt;= m * p，则称这个数列是完美数列。<br>现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。<br>输入格式：<br>输入第一行给出两个正整数N和p，其中N（&lt;= 10^5）是输入的正整数的个数，p（&lt;= 10^9）是给定的参数。第二行给出N个正整数，每个数不超过10^9。<br>输出格式：<br>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p>
<p>输入样例：<br>10 8<br>2 3 20 4 5 1 6 7 8 9</p>
<p>输出样例：<br>8</p>
<h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h1><p>首先将数列从小到大排序，设当前结果为max = 1，当前最长长度为temp = 1；从i = 0～n，j从i + max到n，【因为是为了找最大的max，所以下一次j只要从i的max个后面开始找】每次计算temp若大于max则更新max，最后输出max的值</p>
<h1 id="3-注意"><a href="#3-注意" class="headerlink" title="3. 注意"></a>3. 注意</h1><ul>
<li>m*p有可能超出int表示范围 用long long声明p</li>
<li>采用相当于滑动窗口的形式减少查找次数</li>
</ul>
<h1 id="4-code"><a href="#4-code" class="headerlink" title="4. code"></a>4. code</h1><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//错误示范 未考虑注意中的两点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(a, a+n);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a[i]*p &lt; a[j]) <span class="keyword">break</span>;</span><br><span class="line">            temp++;</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;max) max = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://res.cloudinary.com/dq1yc7tiz/image/upload/v1612534485/PAT%E4%B9%99%E7%BA%A7/PAT%E4%B9%99%E7%BA%A71030_%E9%94%99%E8%AF%AF_az3mma.png" alt="PAT乙级1030"></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//AC代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> p; <span class="comment">//long long</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(a, a+n);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>,temp = <span class="number">1</span>; <span class="comment">//temp不能放进单层循环内</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+max;j&lt;n;j++) <span class="comment">//是max不是temp</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a[i]*p &lt; a[j]) <span class="keyword">break</span>;</span><br><span class="line">            temp++;</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;max) max = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>滑动窗口优化</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/05/pat%E7%94%B2%E7%BA%A71002/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/02/06/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h3 id="各种数值类型的范围"><a href="#各种数值类型的范围" class="headerlink" title="各种数值类型的范围"></a>各种数值类型的范围</h3><h3 id="常见边界情况"><a href="#常见边界情况" class="headerlink" title="常见边界情况"></a>常见边界情况</h3>]]></content>
  </entry>
  <entry>
    <title>PAT甲级1002多项式相加</title>
    <url>/2021/01/25/pat%E7%94%B2%E7%BA%A71002/</url>
    <content><![CDATA[<ul>
<li><a href="#1-input">1. Input</a></li>
<li><a href="#2-output">2. Output</a></li>
<li><a href="#3-sample-input">3. Sample Input</a></li>
<li><a href="#4-sample-output">4. Sample Output</a></li>
<li><a href="#5-%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F">5. 题目大意</a></li>
<li><a href="#6-%E5%88%86%E6%9E%90">6. 分析</a></li>
<li><a href="#7-code">7. Code</a></li>
</ul>
<p>This time, you are supposed to find A+B where A and B are two polynomials.</p>
<h3 id="1-Input"><a href="#1-Input" class="headerlink" title="1. Input"></a>1. Input</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p>
<h3 id="2-Output"><a href="#2-Output" class="headerlink" title="2. Output"></a>2. Output</h3><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>
<h3 id="3-Sample-Input"><a href="#3-Sample-Input" class="headerlink" title="3. Sample Input"></a>3. Sample Input</h3><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p>
<h3 id="4-Sample-Output"><a href="#4-Sample-Output" class="headerlink" title="4. Sample Output"></a>4. Sample Output</h3><p>3 2 1.5 1 2.9 0 3.2</p>
<h3 id="5-题目大意"><a href="#5-题目大意" class="headerlink" title="5. 题目大意"></a>5. 题目大意</h3><p>计算多项式A+B的和</p>
<h3 id="6-分析"><a href="#6-分析" class="headerlink" title="6. 分析"></a>6. 分析</h3><p>设立c数组，长度为指数的最大值，c[i] = j表示指数i的系数为j，接收a和b输入的同时将对应指数的系数加入到c中，累计c中所有非零系数的个数，然后从后往前输出所有系数不为0的指数和系数</p>
<h3 id="7-Code"><a href="#7-Code" class="headerlink" title="7. Code"></a>7. Code</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT 甲 1002A+B多项式.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">double</span> b[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">double</span> c[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> K1,K2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K1);</span><br><span class="line">    <span class="keyword">while</span> (K1--) {</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> A;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;N,&amp;A);</span><br><span class="line">        a[N] = A;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K2);</span><br><span class="line">    <span class="keyword">while</span> (K2--) {</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> B;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;N,&amp;B);</span><br><span class="line">        b[N] = B;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1010</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a[i]!=<span class="number">0</span>||b[i]!=<span class="number">0</span>) {</span><br><span class="line">            c[i] = a[i]+b[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1010</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span>(c[i]!=<span class="number">0</span>) count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1010</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (c[i]!=<span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d %.1lf"</span>,i,c[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT甲级1009多项式相乘</title>
    <url>/2021/02/05/pat%E7%94%B2%E7%BA%A71009/</url>
    <content><![CDATA[<ul>
<li><a href="#1-input-specification">1. Input Specification</a></li>
<li><a href="#2-output-specification">2. Output Specification</a></li>
<li><a href="#3-sample-input">3. Sample Input</a></li>
<li><a href="#4-sample-output">4. Sample Output</a></li>
<li><a href="#5-%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F">5. 题目大意</a></li>
<li><a href="#6-%E6%B3%A8%E6%84%8F">6. 注意</a></li>
</ul>
<p>This time, you are supposed to find A*B where A and B are two polynomials.</p>
<h3 id="1-Input-Specification"><a href="#1-Input-Specification" class="headerlink" title="1. Input Specification"></a>1. Input Specification</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p>
<h3 id="2-Output-Specification"><a href="#2-Output-Specification" class="headerlink" title="2. Output Specification"></a>2. Output Specification</h3><p>For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.</p>
<h3 id="3-Sample-Input"><a href="#3-Sample-Input" class="headerlink" title="3. Sample Input"></a>3. Sample Input</h3><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p>
<h3 id="4-Sample-Output"><a href="#4-Sample-Output" class="headerlink" title="4. Sample Output"></a>4. Sample Output</h3><p>3 3 3.6 2 6.0 1 1.6</p>
<h3 id="5-题目大意"><a href="#5-题目大意" class="headerlink" title="5. 题目大意"></a>5. 题目大意</h3><p>给出两个多项式A和B，求A*B的结果</p>
<h3 id="6-注意"><a href="#6-注意" class="headerlink" title="6. 注意"></a>6. 注意</h3><p>错因：c开了1010。应该开2000+<br>方法：用数组下标作为幂次，用数组元素存储系数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT 甲 1009多项式乘积.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//  题目链接：https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错因：c开了1010。应该开2000+</span></span><br><span class="line"><span class="comment">// 方法：用数组下标作为幂次，用数组元素存储系数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">double</span> b[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">double</span> c[<span class="number">2010</span>]={<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> K1,K2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K1);</span><br><span class="line">    <span class="keyword">while</span> (K1--) {</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> A;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;N,&amp;A);</span><br><span class="line">        a[N] = A;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K2);</span><br><span class="line">    <span class="keyword">while</span> (K2--) {</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> B;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;N,&amp;B);</span><br><span class="line">        b[N] = B;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1010</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a[i]!=<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1010</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(b[j]!=<span class="number">0</span>) {c[i+j] += a[i]*b[j];}</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2010</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span>(c[i]!=<span class="number">0</span>) count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2010</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (c[i]!=<span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d %.1lf"</span>,i,c[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1028人口普查</title>
    <url>/2021/02/05/pat%E4%B9%99%E7%BA%A71028/</url>
    <content><![CDATA[<ul>
<li><a href="#1-input-specification">1. Input Specification</a></li>
<li><a href="#2-output-specification">2. Output Specification</a></li>
<li><a href="#3-sample-input">3. Sample Input</a></li>
<li><a href="#4-sample-output">4. Sample Output</a></li>
<li><a href="#5-%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F">5. 题目大意</a></li>
<li><a href="#6-%E6%B3%A8%E6%84%8F">6. 注意</a></li>
<li><a href="#7-%E6%96%B9%E6%B3%95%E4%B8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%98%E5%82%A8%E9%87%8D%E5%86%99%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0">7. 方法一（结构体存储，重写比较函数）</a></li>
<li><a href="#8-%E6%96%B9%E6%B3%95%E4%BA%8C%E6%97%A5%E6%9C%9F%E5%93%88%E5%B8%8C">8. 方法二（日期哈希）</a></li>
<li><a href="#9-%E6%96%B9%E6%B3%95%E4%B8%89string%E5%A4%84%E7%90%86%E6%97%A5%E6%9C%9F">9. 方法三（String处理日期）</a></li>
</ul>
<p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。<br>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p>
<h1 id="1-Input-Specification"><a href="#1-Input-Specification" class="headerlink" title="1. Input Specification"></a>1. Input Specification</h1><p>输入在第一行给出正整数 N，取值在(0,10^5]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p>
<h1 id="2-Output-Specification"><a href="#2-Output-Specification" class="headerlink" title="2. Output Specification"></a>2. Output Specification</h1><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p>
<h1 id="3-Sample-Input"><a href="#3-Sample-Input" class="headerlink" title="3. Sample Input"></a>3. Sample Input</h1><p>5<br>John 2001/05/12<br>Tom 1814/09/06<br>Ann 2121/01/30<br>James 1814/09/05<br>Steve 1967/11/20</p>
<h1 id="4-Sample-Output"><a href="#4-Sample-Output" class="headerlink" title="4. Sample Output"></a>4. Sample Output</h1><p>3 Tom John</p>
<h1 id="5-题目大意"><a href="#5-题目大意" class="headerlink" title="5. 题目大意"></a>5. 题目大意</h1><p>筛选合法日期后，输出合法日期数，最大最小日期的人的名称</p>
<h1 id="6-注意"><a href="#6-注意" class="headerlink" title="6. 注意"></a>6. 注意</h1><ul>
<li>未考虑边界情况 一个身份都不合理 </li>
<li>数组少开了个0</li>
</ul>
<h1 id="7-方法一（结构体存储，重写比较函数）"><a href="#7-方法一（结构体存储，重写比较函数）" class="headerlink" title="7. 方法一（结构体存储，重写比较函数）"></a>7. 方法一（结构体存储，重写比较函数）</h1><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT乙级1028人口普查.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//错因：1、未考虑边界情况 一个身份都不合理 2、数组少开了个0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">}peo;</span><br><span class="line"></span><br><span class="line">peo persons[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge_unreasonable</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(y&gt;<span class="number">2014</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">2014</span>&amp;&amp;m&gt;<span class="number">9</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">2014</span>&amp;&amp;m==<span class="number">9</span>&amp;&amp;d&gt;<span class="number">6</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;<span class="number">1814</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1814</span>&amp;&amp;m&lt;<span class="number">9</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1814</span>&amp;&amp;m==<span class="number">9</span>&amp;&amp;d&lt;<span class="number">6</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(peo A,peo B)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(A.year!=B.year) <span class="keyword">return</span> A.year&lt;B.year;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(A.month!=B.month) <span class="keyword">return</span> A.month&lt;B.month;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> A.day&lt;B.day;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">int</span> y,m,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d/%d/%d"</span>,name,&amp;y,&amp;m,&amp;d);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="built_in">judge_unreasonable</span>(y, m, d);</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">strcpy</span>(persons[count].name, name);</span><br><span class="line">            persons[count].year = y;</span><br><span class="line">            persons[count].month = m;</span><br><span class="line">            persons[count].day = d;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(persons, persons+count, cmp);</span><br><span class="line"><span class="comment">//    边界</span></span><br><span class="line">    <span class="keyword">if</span>(count!=<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %s"</span>,count,persons[<span class="number">0</span>].name,persons[count<span class="number">-1</span>].name);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="8-方法二（日期哈希）"><a href="#8-方法二（日期哈希）" class="headerlink" title="8. 方法二（日期哈希）"></a>8. 方法二（日期哈希）</h1><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT乙级1028人口普查.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//错因：1、未考虑边界情况 一个身份都不合理 2、数组少开了个0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> MAX=<span class="number">18140906</span>,MIN=<span class="number">20140906</span>;</span><br><span class="line">    string MAX_name,MIN_name;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        string name;</span><br><span class="line">        <span class="keyword">int</span> y,m,d;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d/%d/%d"</span>,&amp;y,&amp;m,&amp;d);</span><br><span class="line">        <span class="keyword">int</span> tmp = y*<span class="number">10000</span>+m*<span class="number">100</span>+d;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (tmp&lt;=<span class="number">20140906</span>&amp;&amp;tmp&gt;=<span class="number">18140906</span>) {</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (tmp&gt;=MAX) {</span><br><span class="line">                MAX = tmp;</span><br><span class="line">                MAX_name = name;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (tmp&lt;=MIN) {</span><br><span class="line">                MIN = tmp;</span><br><span class="line">                MIN_name = name;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cnt==<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %s"</span>,cnt,MIN_name.<span class="built_in">c_str</span>(),MAX_name.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="9-方法三（String处理日期）"><a href="#9-方法三（String处理日期）" class="headerlink" title="9. 方法三（String处理日期）"></a>9. 方法三（String处理日期）</h1><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT乙级1028人口普查.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//错因：1、未考虑边界情况 一个身份都不合理 2、数组少开了个0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    string MAX_name,MIN_name;</span><br><span class="line">    string MAX = <span class="string">"1814/09/06"</span>,MIN = <span class="string">"2014/09/06"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        string name,tmp;</span><br><span class="line">        cin&gt;&gt;name&gt;&gt;tmp;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (tmp&lt;=<span class="string">"2014/09/06"</span>&amp;&amp;tmp&gt;=<span class="string">"1814/09/06"</span>) {</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (tmp&gt;=MAX) {</span><br><span class="line">                MAX = tmp;</span><br><span class="line">                MAX_name = name;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (tmp&lt;=MIN) {</span><br><span class="line">                MIN = tmp;</span><br><span class="line">                MIN_name = name;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cnt==<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %s"</span>,cnt,MIN_name.<span class="built_in">c_str</span>(),MAX_name.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>PAT 乙级</category>
      </categories>
      <tags>
        <tag>日期 结构体模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT甲级1006</title>
    <url>/2021/02/01/pat%E7%94%B2%E7%BA%A71006/</url>
    <content><![CDATA[<ul>
<li><a href="#1-question">1. Question</a><ul>
<li><a href="#11-input-specification">1.1. Input Specification:</a></li>
<li><a href="#12-output-specification">1.2. Output Specification</a></li>
<li><a href="#13-sample-input">1.3. Sample Input</a></li>
<li><a href="#14-sample-output">1.4. Sample Output</a></li>
</ul>
</li>
<li><a href="#2-thinking">2. Thinking</a></li>
<li><a href="#3-code">3. code</a></li>
</ul>
<h1 id="1-Question"><a href="#1-Question" class="headerlink" title="1. Question"></a>1. Question</h1><p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p>
<h2 id="1-1-Input-Specification"><a href="#1-1-Input-Specification" class="headerlink" title="1.1. Input Specification:"></a>1.1. Input Specification:</h2><p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:</p>
<p>ID_number Sign_in_time Sign_out_time</p>
<p>where times are given in the format HH:MM:SS, and ID_number is a string with no more than 15 characters.</p>
<h2 id="1-2-Output-Specification"><a href="#1-2-Output-Specification" class="headerlink" title="1.2. Output Specification"></a>1.2. Output Specification</h2><p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p>
<p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p>
<h2 id="1-3-Sample-Input"><a href="#1-3-Sample-Input" class="headerlink" title="1.3. Sample Input"></a>1.3. Sample Input</h2><p>3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40</p>
<h2 id="1-4-Sample-Output"><a href="#1-4-Sample-Output" class="headerlink" title="1.4. Sample Output"></a>1.4. Sample Output</h2><p>SC3021234 CS301133</p>
<h1 id="2-Thinking"><a href="#2-Thinking" class="headerlink" title="2. Thinking"></a>2. Thinking</h1><p>时间哈希</p>
<h1 id="3-code"><a href="#3-code" class="headerlink" title="3. code"></a>3. code</h1><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT甲级1006.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/6.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> earid[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> lateid[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> eartime = <span class="number">86400</span>;</span><br><span class="line">    <span class="keyword">int</span> latetime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="comment">//    scanf后面如果接</span></span><br><span class="line"><span class="comment">//    getchar();</span></span><br><span class="line">    <span class="keyword">while</span> (N--) {</span><br><span class="line">        <span class="keyword">int</span> h1,m1,s1,h2,m2,s2;</span><br><span class="line"><span class="comment">//        不能用gets 不然把后面的数字也读到字符数组里了</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d:%d:%d %d:%d:%d"</span>,id,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2);</span><br><span class="line">        <span class="keyword">int</span> tmp1 = <span class="number">3600</span>*h1+m1*<span class="number">60</span>+s1;</span><br><span class="line">        <span class="keyword">int</span> tmp2 = <span class="number">3600</span>*h2+m2*<span class="number">60</span>+s2;</span><br><span class="line">        <span class="keyword">if</span>(tmp1&lt;eartime) {eartime = tmp1;<span class="built_in">strcpy</span>(earid,id);}</span><br><span class="line">        <span class="keyword">if</span>(tmp2&gt;latetime) {latetime = tmp2;<span class="built_in">strcpy</span>(lateid,id);}</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %s"</span>,earid,lateid);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>PAT 甲级</category>
      </categories>
      <tags>
        <tag>时间哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode111</title>
    <url>/2021/04/08/leetcode111/</url>
    <content><![CDATA[<ul>
<li><a href="#1-%E9%A2%98%E7%9B%AE">1. 题目</a><ul>
<li><a href="#11-%E8%BE%93%E5%85%A5">1.1. 输入</a></li>
<li><a href="#12-%E8%BE%93%E5%87%BA">1.2. 输出</a></li>
<li><a href="#13-%E8%BE%93%E5%85%A5">1.3. 输入</a></li>
<li><a href="#14-%E8%BE%93%E5%87%BA">1.4. 输出</a></li>
</ul>
</li>
<li><a href="#2-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1-%E6%B7%B1%E6%90%9C">2. 解题思路1: 深搜</a></li>
<li><a href="#3-%E4%BB%A3%E7%A0%811">3. 代码1</a></li>
<li><a href="#4-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2-%E5%AE%BD%E6%90%9C">4. 解题思路2: 宽搜</a></li>
<li><a href="#5-%E4%BB%A3%E7%A0%812">5. 代码2</a></li>
</ul>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p>
<h2 id="1-1-输入"><a href="#1-1-输入" class="headerlink" title="1.1. 输入"></a>1.1. 输入</h2><p>root = [3,9,20,null,null,15,7]</p>
<h2 id="1-2-输出"><a href="#1-2-输出" class="headerlink" title="1.2. 输出"></a>1.2. 输出</h2><p>2</p>
<h2 id="1-3-输入"><a href="#1-3-输入" class="headerlink" title="1.3. 输入"></a>1.3. 输入</h2><p>root = [2,null,3,null,4,null,5,null,6]</p>
<h2 id="1-4-输出"><a href="#1-4-输出" class="headerlink" title="1.4. 输出"></a>1.4. 输出</h2><p>5</p>
<h1 id="2-解题思路1-深搜"><a href="#2-解题思路1-深搜" class="headerlink" title="2. 解题思路1: 深搜"></a>2. 解题思路1: 深搜</h1><h1 id="3-代码1"><a href="#3-代码1" class="headerlink" title="3. 代码1"></a>3. 代码1</h1><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="4-解题思路2-宽搜"><a href="#4-解题思路2-宽搜" class="headerlink" title="4. 解题思路2: 宽搜"></a>4. 解题思路2: 宽搜</h1><h1 id="5-代码2"><a href="#5-代码2" class="headerlink" title="5. 代码2"></a>5. 代码2</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> deep=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">bfs</span>(root,deep);</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;deep)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* end=root;</span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            TreeNode* p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left==<span class="literal">NULL</span>&amp;&amp;p-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                deep=level;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left){q.<span class="built_in">push</span>(p-&gt;left);}</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right){q.<span class="built_in">push</span>(p-&gt;right);}</span><br><span class="line">            <span class="keyword">if</span>(p==end)</span><br><span class="line">            {</span><br><span class="line">                end = q.<span class="built_in">back</span>();</span><br><span class="line">                level++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>深搜</tag>
        <tag>宽搜</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode26</title>
    <url>/2021/04/08/leetcode26/</url>
    <content><![CDATA[<ul>
<li><a href="#1-%E9%A2%98%E7%9B%AE">1. 题目</a></li>
<li><a href="#2-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1">2. 解题思路1</a><ul>
<li><a href="#21-%E4%BB%A3%E7%A0%811">2.1. 代码1</a></li>
</ul>
</li>
<li><a href="#3-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2">3. 解题思路2</a><ul>
<li><a href="#301-%E4%BB%A3%E7%A0%812">3.0.1. 代码2</a></li>
</ul>
</li>
</ul>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。nums 已按升序排列</p>
<h1 id="2-解题思路1"><a href="#2-解题思路1" class="headerlink" title="2. 解题思路1"></a>2. 解题思路1</h1><p>自己写的一个模拟删除过程，维护一个计数器够数了就减</p>
<h2 id="2-1-代码1"><a href="#2-1-代码1" class="headerlink" title="2.1. 代码1"></a>2.1. 代码1</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[j]==nums[j<span class="number">-1</span>])</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">2</span>)</span><br><span class="line">            {</span><br><span class="line">                nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>()+j);</span><br><span class="line">                len--,j--,cnt--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="3-解题思路2"><a href="#3-解题思路2" class="headerlink" title="3. 解题思路2"></a>3. 解题思路2</h1><p>看完leetcode官方双指针后写的C++版本，但是还是干不过你们<br><img src="https://pic.leetcode-cn.com/1617850114-hzBzol-%E6%88%AA%E5%B1%8F2021-04-08%20%E4%B8%8A%E5%8D%8810.48.20.png" alt="截屏2021-04-08 上午10.48.20.png"></p>
<h3 id="3-0-1-代码2"><a href="#3-0-1-代码2" class="headerlink" title="3.0.1. 代码2"></a>3.0.1. 代码2</h3><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i])</span><br><span class="line">            {</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode80</title>
    <url>/2021/04/08/leetcode80/</url>
    <content><![CDATA[<ul>
<li><a href="#1-%E9%A2%98%E7%9B%AE">1. 题目</a></li>
<li><a href="#2-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1">2. 解题思路1</a><ul>
<li><a href="#21-%E4%BB%A3%E7%A0%811">2.1. 代码1</a></li>
</ul>
</li>
<li><a href="#3-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2">3. 解题思路2</a><ul>
<li><a href="#31-%E4%BB%A3%E7%A0%812%E7%BD%91%E4%B8%8A%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E9%A2%98%E8%A7%A3">3.1. 代码2(网上的双指针题解)</a></li>
</ul>
</li>
</ul>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。nums 升序</p>
<h1 id="2-解题思路1"><a href="#2-解题思路1" class="headerlink" title="2. 解题思路1"></a>2. 解题思路1</h1><p>自己写的一个模拟删除过程，维护一个计数器够数了就减</p>
<h2 id="2-1-代码1"><a href="#2-1-代码1" class="headerlink" title="2.1. 代码1"></a>2.1. 代码1</h2><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">            {</span><br><span class="line">                cnt++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                cnt=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">3</span>)</span><br><span class="line">            {</span><br><span class="line">                nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>()+i);</span><br><span class="line">                cnt--;</span><br><span class="line">                len--;</span><br><span class="line">                i--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="3-解题思路2"><a href="#3-解题思路2" class="headerlink" title="3. 解题思路2"></a>3. 解题思路2</h1><ul>
<li><p>慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度</p>
</li>
<li><p>即 nums[left],nums[right] 表示待检查的第一个元素，nums[left−1] 为上一个应该被保留的元素所移动到的指定位置.</p>
</li>
<li><p>检查上上个应该被保留的元素 nums[left-2] 是否和当前待检查元素 nums[right] 相同。当且仅当 nums[left-2]=nums[right]时，当前待检查元素 nums[right] 不应该被保留</p>
</li>
<li><p>用left-2内的元素都已经合法，通过right与left-2的比较，表示当前的元素欲检查的元素是否需要将left指向的元素更新</p>
<ul>
<li>如果相同，right指针继续往后移，left指针不动。</li>
<li>如果不相同，right指针指向的值要覆盖掉left指向的值，然后他们同时往后移一步</li>
</ul>
</li>
</ul>
<h2 id="3-1-代码2-网上的双指针题解"><a href="#3-1-代码2-网上的双指针题解" class="headerlink" title="3.1. 代码2(网上的双指针题解)"></a>3.1. 代码2(网上的双指针题解)</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; nums.length; right++) {</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">2</span> || nums[right] != nums[left - <span class="number">2</span>])</span><br><span class="line">            nums[left++] = nums[right];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>商务数据分析1</title>
    <url>/2021/01/25/%E5%95%86%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%901/</url>
    <content><![CDATA[<h1 id="参数更新方法"><a href="#参数更新方法" class="headerlink" title="参数更新方法"></a>参数更新方法</h1><ul>
<li>若要优化损失函数得到损失函数的极小值，可对每个参数求偏导，令偏导为0，联立方程求解最优的参数。但参数多时代价太大。故采用梯度下降法不断逼近损失函数的极小值</li>
</ul>
<h2 id="方向导数，梯度概念"><a href="#方向导数，梯度概念" class="headerlink" title="方向导数，梯度概念"></a>方向导数，梯度概念</h2><img src="https://res.cloudinary.com/dq1yc7tiz/image/upload/v1617793901/deep%20learning/%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E5%AE%9A%E4%B9%89_dcs0ri.jpg" width="50%" height="50%">

<img src="https://res.cloudinary.com/dq1yc7tiz/image/upload/v1617793857/deep%20learning/%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0%E6%8E%A8%E5%AF%BC_hu06da.jpg" width="50%" height="50%">

<img src="https://res.cloudinary.com/dq1yc7tiz/image/upload/v1617793864/deep%20learning/%E6%A2%AF%E5%BA%A6%E5%AE%9A%E4%B9%89_pingu0.jpg" width="50%" height="50%">

<img src="https://res.cloudinary.com/dq1yc7tiz/image/upload/v1617793865/deep%20learning/%E6%A2%AF%E5%BA%A6%E6%8E%A8%E5%AF%BC_jf4mp9.jpg" width="50%" height="50%">

<h2 id="梯度下降数学推导"><a href="#梯度下降数学推导" class="headerlink" title="梯度下降数学推导"></a>梯度下降数学推导</h2><h1 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h1><ul>
<li>批量训练<ul>
<li>以所有样本为训练为一个epoch，对所有样本的loss求和后反向传播更新参数</li>
</ul>
</li>
<li>随机梯度下降<ul>
<li>随机挑一个样本训练为一个epoch，算出一个样本的loss后反向传播更新参数</li>
</ul>
</li>
<li>mini batch<ul>
<li>随机选十几个样本（打比方）训练为一个epoch，算出这十几个样本求和后的loos反向传播更新参数</li>
</ul>
</li>
</ul>
<h1 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h1><ul>
<li>网络反向传播时到达靠近输入层的网络时梯度更新的值非常的小</li>
</ul>
<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><ul>
<li>Sigmod函数 (两头过于平坦，输出值域不对称，相当于没有梯度)<ul>
<li>$Sigmod(x) = \frac{1}{1+e^{-x}}, Sigmod(x) \in (0,1)$</li>
</ul>
</li>
<li>双曲正切（tanh）（两头过于平坦，输出值域对称，相当于没有梯度）<ul>
<li>$tanh(x) = \frac{e^{x}-e^{-x}}{e^{-x}+e^{x}}, tanh(x) \in (-1,1)$</li>
</ul>
</li>
<li>ReLU函数（常用，收敛速度比前两种快，计算高效）<ul>
<li>$Relu(x) = \max{0,x} $</li>
</ul>
</li>
<li>Leaky ReLU（解决死亡神经元问题）<ul>
<li>$$f(x) = \begin{cases}<br>\alpha \ast x &amp; x &lt; 0 \<br>x &amp;x \geq 0<br>\end{cases}$$</li>
</ul>
</li>
</ul>
<h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><ul>
<li>最小平方误差（MSE）<ul>
<li>$MSE = \frac{1}{2n}\displaystyle \sum^{n}_{i=1}{(\hat y_i-y_i)^2}$</li>
</ul>
</li>
<li>交叉熵(二分类问题,也可以用于[0,1]区间的回归问题)<ul>
<li>$$J(w) = -\frac{1}{N}\displaystyle \sum^{N}_{n=1}{y_nlog{\hat{y_n}}+(1-y_n)log(1-\hat y_n)}$$<ul>
<li>($y_n$为第n个样本的真值，$\hat y_n$为第n个样本的预测值)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h1><ul>
<li>基于经验手动调</li>
<li>固定学习率</li>
<li>动量法动态调整</li>
<li>随机梯度下降</li>
<li>Adam自动调整</li>
</ul>
<h1 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h1><ul>
<li>使用测试集（尽可能与训练集互斥进行泛化误差的估计）<ul>
<li>留出法：将数据姐划分一部分做测试集一部分做训练集，测试集与训练集正负样本分布尽可能均匀。常见将$\frac{2}{3}-\frac{4}{5}$的数据集作为训练集。可多次留出，对测试集结果取平均。</li>
<li>交叉验证法：如十折交叉验证，分10份，9训练1测试，进行10次测试，每次测试集合两两不同，对测试集的结果取平均。</li>
<li>自助法：</li>
</ul>
</li>
</ul>
<h1 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h1><ul>
<li>参数范数惩罚：惩罚性成本函数，正则化（回归，分类问题都可用）<ul>
<li>$L2$正则化（$W_i$为平方，一次时为L1正则化）<ul>
<li>$J = \frac{1}{2n}\displaystyle \sum^{n}<em>{i=1}{(\hat y_i-y_i)^2}+\lambda \displaystyle \sum^{m}</em>{j=1}{W_i^2}$  <ul>
<li>解释：当$\lambda$取很大时要使得$J$很小则只能使某些权重$W_i$为0，从而降低模型的复杂度，防止过拟合。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据增强</li>
<li>提前终止<ul>
<li>（对检验样本）测试时过了10个epoche（例如），损失函数不减反增则终止检验。</li>
</ul>
</li>
<li>Bagging等集成方法</li>
<li>Dropout<ul>
<li>在每个训练的epoche时随机固定删除一部分神经元（这部分被删除的神经元保存初始参数，训练过程不修正参数）</li>
<li>在测试网络时将删除的神经元连上</li>
</ul>
</li>
<li><h2 id="动量（Momentum）"><a href="#动量（Momentum）" class="headerlink" title="动量（Momentum）"></a>动量（Momentum）</h2></li>
</ul>
]]></content>
      <categories>
        <category>DL</category>
      </categories>
      <tags>
        <tag>BP神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode153</title>
    <url>/2021/04/09/leetcode153/</url>
    <content><![CDATA[<ul>
<li><a href="#1-%E9%A2%98%E7%9B%AE">1. 题目</a><ul>
<li><a href="#11-%E8%BE%93%E5%85%A5">1.1. 输入</a></li>
<li><a href="#12-%E8%BE%93%E5%87%BA">1.2. 输出</a></li>
<li><a href="#13-%E8%A7%A3%E9%87%8A">1.3. 解释</a></li>
<li><a href="#14-%E8%BE%93%E5%85%A5">1.4. 输入</a></li>
<li><a href="#15-%E8%BE%93%E5%87%BA">1.5. 输出</a></li>
<li><a href="#16-%E8%A7%A3%E9%87%8A">1.6. 解释</a></li>
</ul>
</li>
<li><a href="#2-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1">2. 解题思路1</a></li>
<li><a href="#3-%E4%BB%A3%E7%A0%811">3. 代码1</a></li>
<li><a href="#4-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2">4. 解题思路2</a></li>
<li><a href="#5-%E4%BB%A3%E7%A0%812">5. 代码2</a></li>
</ul>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<h2 id="1-1-输入"><a href="#1-1-输入" class="headerlink" title="1.1. 输入"></a>1.1. 输入</h2><p>nums = [3,4,5,1,2]</p>
<h2 id="1-2-输出"><a href="#1-2-输出" class="headerlink" title="1.2. 输出"></a>1.2. 输出</h2><p>1</p>
<h2 id="1-3-解释"><a href="#1-3-解释" class="headerlink" title="1.3. 解释"></a>1.3. 解释</h2><p>原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</p>
<h2 id="1-4-输入"><a href="#1-4-输入" class="headerlink" title="1.4. 输入"></a>1.4. 输入</h2><p>nums = [11,13,15,17]</p>
<h2 id="1-5-输出"><a href="#1-5-输出" class="headerlink" title="1.5. 输出"></a>1.5. 输出</h2><p>11</p>
<h2 id="1-6-解释"><a href="#1-6-解释" class="headerlink" title="1.6. 解释"></a>1.6. 解释</h2><p>原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</p>
<h1 id="2-解题思路1"><a href="#2-解题思路1" class="headerlink" title="2. 解题思路1"></a>2. 解题思路1</h1><p>暴力</p>
<h1 id="3-代码1"><a href="#3-代码1" class="headerlink" title="3. 代码1"></a>3. 代码1</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//78% 39.35%</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="4-解题思路2"><a href="#4-解题思路2" class="headerlink" title="4. 解题思路2"></a>4. 解题思路2</h1><p>二分查找 保证最小值在区间[low,high]之间 可以以值画图模拟<br>二分查找写法区别：</p>
<ul>
<li>low&lt;=high low=mid+1,high=mid-1 判断时加nums[mid]==target判断（左中右）</li>
<li>low &lt; high low=mid,high=mid-1或者low=mid+1,high=mid  两边夹出结果（左右）</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/</a></p>
<h1 id="5-代码2"><a href="#5-代码2" class="headerlink" title="5. 代码2"></a>5. 代码2</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,mid,high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        {</span><br><span class="line">            mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[high])</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode154</title>
    <url>/2021/04/10/leetcode154/</url>
    <content><![CDATA[<ul>
<li><p><a href="#1-%E9%A2%98%E7%9B%AE">1. 题目</a></p>
<ul>
<li><a href="#11-%E8%BE%93%E5%85%A5nums--135">1.1. 输入：nums = [1,3,5]</a></li>
<li><a href="#12-%E8%BE%93%E5%87%BA1">1.2. 输出：1</a></li>
<li><a href="#13-%E8%BE%93%E5%85%A5nums--22201">1.3. 输入：nums = [2,2,2,0,1]</a></li>
<li><a href="#14-%E8%BE%93%E5%87%BA0">1.4. 输出：0</a></li>
</ul>
</li>
<li><p><a href="#1-%E9%A2%98%E7%9B%AE">1. 题目</a></p>
<ul>
<li><a href="#11-%E8%BE%93%E5%85%A5">1.1. 输入</a></li>
<li><a href="#12-%E8%BE%93%E5%87%BA">1.2. 输出</a></li>
<li><a href="#13-%E8%BE%93%E5%85%A5">1.3. 输入</a></li>
<li><a href="#14-%E8%BE%93%E5%87%BA">1.4. 输出</a></li>
</ul>
</li>
<li><p><a href="#2-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1">2. 解题思路1</a></p>
</li>
<li><p><a href="#3-%E4%BB%A3%E7%A0%811">3. 代码1</a></p>
</li>
<li><p><a href="#4-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2">4. 解题思路2</a></p>
</li>
<li><p><a href="#5-%E4%BB%A3%E7%A0%812">5. 代码2</a></p>
</li>
</ul>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<h2 id="1-1-输入"><a href="#1-1-输入" class="headerlink" title="1.1. 输入"></a>1.1. 输入</h2><p>nums = [1,3,5]</p>
<h2 id="1-2-输出"><a href="#1-2-输出" class="headerlink" title="1.2. 输出"></a>1.2. 输出</h2><p>1</p>
<h2 id="1-3-输入"><a href="#1-3-输入" class="headerlink" title="1.3. 输入"></a>1.3. 输入</h2><p>nums = [2,2,2,0,1]</p>
<h2 id="1-4-输出"><a href="#1-4-输出" class="headerlink" title="1.4. 输出"></a>1.4. 输出</h2><p>0</p>
<h1 id="2-解题思路1"><a href="#2-解题思路1" class="headerlink" title="2. 解题思路1"></a>2. 解题思路1</h1><p>暴力</p>
<h1 id="3-代码1"><a href="#3-代码1" class="headerlink" title="3. 代码1"></a>3. 代码1</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>]) <span class="keyword">return</span> nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h1 id="4-解题思路2"><a href="#4-解题思路2" class="headerlink" title="4. 解题思路2"></a>4. 解题思路2</h1><p>二分查找 在nums[mid]==nums[high]时无法判读最小值在左半区间还是右半区间</p>
<h1 id="5-代码2"><a href="#5-代码2" class="headerlink" title="5. 代码2"></a>5. 代码2</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,mid,high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        {</span><br><span class="line">            mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[high]) high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[high])low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> --high;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode88</title>
    <url>/2021/04/10/leetcode88/</url>
    <content><![CDATA[<ul>
<li><a href="#1-%E9%A2%98%E7%9B%AE">1. 题目</a><ul>
<li><a href="#11-%E8%BE%93%E5%85%A5">1.1. 输入</a></li>
<li><a href="#12-%E8%BE%93%E5%87%BA">1.2. 输出</a></li>
<li><a href="#13-%E8%BE%93%E5%85%A5">1.3. 输入</a></li>
<li><a href="#14-%E8%BE%93%E5%87%BA">1.4. 输出</a></li>
</ul>
</li>
<li><a href="#2-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF1">2. 解题思路1</a></li>
<li><a href="#3-%E4%BB%A3%E7%A0%811">3. 代码1</a></li>
<li><a href="#4-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF2%E7%9C%8B%E5%AE%8C%E9%A2%98%E8%A7%A3%E6%89%8D%E7%9F%A5%E9%81%93">4. 解题思路2（看完题解才知道）</a></li>
<li><a href="#5-%E4%BB%A3%E7%A0%812">5. 代码2</a></li>
</ul>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>给你两个有序整数数组&nbsp;nums1 和 nums2，请你将 nums2 合并到&nbsp;nums1&nbsp;中，使 nums1 成为一个有序数组。</p>
<p>初始化&nbsp;nums1 和 nums2 的元素数量分别为&nbsp;m 和 n 。你可以假设&nbsp;nums1 的空间大小等于&nbsp;m + n，这样它就有足够的空间保存来自 nums2 的元素。</p>
<h2 id="1-1-输入"><a href="#1-1-输入" class="headerlink" title="1.1. 输入"></a>1.1. 输入</h2><p>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</p>
<h2 id="1-2-输出"><a href="#1-2-输出" class="headerlink" title="1.2. 输出"></a>1.2. 输出</h2><p>[1,2,2,3,5,6]</p>
<h2 id="1-3-输入"><a href="#1-3-输入" class="headerlink" title="1.3. 输入"></a>1.3. 输入</h2><p>nums1 = [1], m = 1, nums2 = [], n = 0</p>
<h2 id="1-4-输出"><a href="#1-4-输出" class="headerlink" title="1.4. 输出"></a>1.4. 输出</h2><p>[1]</p>
<h1 id="2-解题思路1"><a href="#2-解题思路1" class="headerlink" title="2. 解题思路1"></a>2. 解题思路1</h1><p>常规合并</p>
<h1 id="3-代码1"><a href="#3-代码1" class="headerlink" title="3. 代码1"></a>3. 代码1</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> sorted[m + n];</span><br><span class="line">       <span class="keyword">int</span> cur;</span><br><span class="line">       <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) {</span><br><span class="line">           <span class="keyword">if</span> (p1 == m) {</span><br><span class="line">               cur = nums2[p2++];</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) {</span><br><span class="line">               cur = nums1[p1++];</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) {</span><br><span class="line">               cur = nums1[p1++];</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               cur = nums2[p2++];</span><br><span class="line">           }</span><br><span class="line">           sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != m + n; ++i) {</span><br><span class="line">           nums1[i] = sorted[i];</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="4-解题思路2（看完题解才知道）"><a href="#4-解题思路2（看完题解才知道）" class="headerlink" title="4. 解题思路2（看完题解才知道）"></a>4. 解题思路2（看完题解才知道）</h1><p>nums1的后半部分是空的，可以直接覆盖而不会影响结果。因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进nums1的最后面。</p>
<h1 id="5-代码2"><a href="#5-代码2" class="headerlink" title="5. 代码2"></a>5. 代码2</h1><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="number">-1</span>) {</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">-1</span>) {</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) {</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            }</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>PAT乙级</category>
      </categories>
      <tags>
        <tag>归并</tag>
        <tag>逆双指针</tag>
      </tags>
  </entry>
</search>

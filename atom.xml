<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HCs blog</title>
  
  <subtitle>勿于浮沙筑高台</subtitle>
  <link href="https://csberlin.github.io/atom.xml" rel="self"/>
  
  <link href="https://csberlin.github.io/"/>
  <updated>2021-05-05T03:34:01.694Z</updated>
  <id>https://csberlin.github.io/</id>
  
  <author>
    <name>HC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FDU上岸经验贴</title>
    <link href="https://csberlin.github.io/2021/05/05/FDU%E4%B8%8A%E5%B2%B8%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
    <id>https://csberlin.github.io/2021/05/05/FDU%E4%B8%8A%E5%B2%B8%E7%BB%8F%E9%AA%8C%E8%B4%B4/</id>
    <published>2021-05-05T13:56:04.000Z</published>
    <updated>2021-05-05T03:34:01.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>抱着想写点什么记录考研的心态，也应某朋友的要求写下这个经验贴。</p><p>看完不求点赞转发，如果能从我的经历中获得什么，我会感到开心和欣慰。</p><span id="more"></span><h1 id="考试科目"><a href="#考试科目" class="headerlink" title="考试科目"></a>考试科目</h1><table><thead><tr><th>政治</th><th>英语二</th><th>数学二</th><th>专业课</th><th>总分</th></tr></thead><tbody><tr><td>64</td><td>76</td><td>126</td><td>113</td><td>377</td></tr></tbody></table><h2 id="21考况分析"><a href="#21考况分析" class="headerlink" title="21考况分析"></a>21考况分析</h2><h3 id="FDU考况"><a href="#FDU考况" class="headerlink" title="FDU考况"></a>FDU考况</h3><blockquote><p>电子信息专硕，22408据说入复试平均分379（有错请指正）。400分➕的有100+个人，但分数线355！！！（其实是临时小扩了70-80人左右），比起隔壁科软今年FDU是真良心了。（或者说考22408的学校FDU良心）</p></blockquote><h3 id="整体考况"><a href="#整体考况" class="headerlink" title="整体考况"></a>整体考况</h3><blockquote><p>如表所示，我分数不算高。简单点评下今年各科，政治今年上海压分了（问了同学普遍低），所以各位政治辅导老师压没压中答题和主观题的分数在上海地区并没有太大关系。英语没压，但考完整体难度个人感觉比18-20年附近的卷子大，尤其完形填空。数学二可能第一年换新题型，题目简单但有小坑，把小坑避开还是需要你扎实的理论基础，考场上的细心和计算基础。408今年整体卷子比17-20年难度要低，但不排除有难偏题存在。所以数学，408两个大家考出来都好看，数学上限高，408下限高。</p></blockquote><h3 id="我的考况"><a href="#我的考况" class="headerlink" title="我的考况"></a>我的考况</h3><blockquote><p>（具体原因后说部分我会强调和加粗）</p><ol><li><p>政治考完感觉良好，出来吓一跳。（为什么产生这种原因后面会说。。。）</p></li><li><p>英语二正常发挥（错了3-4个阅读（包括新题型），6-7个完型）</p></li><li><p>数学二大翻车，具体原因后面说，错了第三题选择(数学应用)和最后一题填空(4阶行列式计算)，一个二重积分答题上限写错没了11分，一道二重积分最后计算出错（步骤错的挺靠前的）应该只扣了2-3分。这样来看步骤分给的会很多，<strong>请22考生注意拿好步骤分</strong></p></li><li><p>408小翻车，选择应该错了6个，2个偏题，还有就是知识错漏导致。<strong>22考生注意全面复习，不要抱侥幸心理</strong>，算法题用了搜索，应该是没给分。计网最后大题应该只有一半分，但分数还是觉得偏低。（anyway，结果好，这都无所谓了）</p><p>比起我身边某439的大佬，我连菜鸡都不如。</p></li></ol></blockquote><h1 id="本人概况"><a href="#本人概况" class="headerlink" title="本人概况"></a>本人概况</h1><p>不谈基础，不谈时间分配开始讲经验就在耍流氓了。双非，科班。四级524，六级472。数学课程水期末分数没太大参考意义，大家可以视为我有一定数学基础。专业课都学的一般，也有基础。政治基础为0。</p><h2 id="总体时间"><a href="#总体时间" class="headerlink" title="总体时间"></a>总体时间</h2><ol><li><p>3-5月宅家摸鱼决定考研，英语单词用墨墨（有pj版的），数学听汤配套1800写到了积分。</p></li><li><p>5-6月开始7+小时准备，专业课前期因迷之自信和走了点弯路（6月10号才算正式开搞，晚了），6月初开的线代。期间有慢跑，调节情绪和身体基础。单词每个星期+10。</p></li><li><p>7-8月暑假，开始9+小时准备，期间基本无休，身体状况好就多学，不舒服了就休息。7月5数学开始化，7月中开始做英语二真题，一天一个阅读。单词开始发现背不完了，每个星期+50，8月底达到每天500词。数学强化结束。</p></li><li><p>9-10月，9月中开政治，9月6号专业课王道2轮（从6月份开始1个月左右一本，总共4本专业课）。9.22号刷完英语阅读真题。</p></li><li><p>10-11月 10月中政治1000题刷完，专业课3轮，英语开始准备小大作文+新题型，数学05-20年真题一刷结束，10.27开数学模拟。</p></li><li><p>11-12.25 数学还在刷模拟（最后可能刷了25套这样），11月中下旬肖八出来了，出来一天一套<strong>立刻做完</strong>，12月中旬肖四出来，直接开背，选择题抽空写。考前过过48选择题。专业课开真题+纠错。英语完形填空+背作文。</p></li></ol><h2 id="时间分配"><a href="#时间分配" class="headerlink" title="时间分配"></a>时间分配</h2><p>8:00am-10:00pm，平均学习时长9-10h</p><p>这里只列举后期时间（因为时间不可能一成不变，根据个人微调，但总体要<strong>保证后期数学有3-4h，专业课3-4h，英语1h，政治30min-1h</strong>）：</p><p>因为早上考数学，我选择8点左右到图书馆背30分钟单词，8:30-11:30搞数学，下午2:00左右再搞一小时数学，剩下时间给英语搞到3:00左右-5:00左右（后期匀了45分钟给政治），晚上6:30坐定开始专业课到10:00图书馆闭馆，然后10:30分-11:20背单词。</p><h1 id="科目建议"><a href="#科目建议" class="headerlink" title="科目建议"></a>科目建议</h1><blockquote><p>总体思路：按时间投入划分，优先级为数学&gt;专业课&gt;英语&gt;政治，跨考生的话专业课优先级应放在第一位</p></blockquote><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><h3 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h3><p><strong>强调：政治资料拿到就用，立刻马上，是选择特训就做选择，是大题资料就背大题，你后期时间是根本不够用的！！！</strong></p><ul><li><p>优先级：选择&gt;大题</p></li><li><p>资料：肖秀荣1000，肖四八，核心考案，风中劲草（后期基本没时间看，购买慎重）</p></li><li><p>马原看一章徐涛视频用核心考案对应，然后做一章1000题选择，其余我是直接上1000题。9月中一刷1000题期间持续了一个多月。大题后期用肖四，肖八（肖四为主）。<strong>48里的选择根据往年考生和我今年的经历是可以压到几题原题的。</strong>  <strong>政治不要相信市面上或者各种渠道获得的真题信息， 即使他是有出题背景的也不例外。</strong></p></li></ul><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>选择题我建议1000题刷两遍以上，我1000只刷了一遍，现在就是无比的后悔。（<strong>9月中1000题应该就出了，能提前拿到就先刷。</strong>）肖48是1000题的选择提炼和热点汇编，1000题的选择最全。x宝上有1000题刷题的本子，方便更正和二刷1000题。<strong>不要在1000题上直接写选项！！！</strong> 选项可以打在草稿本上，然后错的在1000题中用记号标记出来。</p><h3 id="大题"><a href="#大题" class="headerlink" title="大题"></a>大题</h3><p>政治<strong>选择占大部头</strong>，其实从压分和当年大题压不压中大题都好像没什么所谓，因为到后来基本上只有背肖四+一个其他老师的关于大题知识的资料，p.s：你还不一定背得住。所以我得出的结论是时间有限情况下不如直接肖四压宝再加点空卡的套话。可以说政治的大题稳定保证了我后期考试的心态。最后允许我说一句：<strong>感谢肖老！感谢空卡</strong></p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><h3 id="总体思路-1"><a href="#总体思路-1" class="headerlink" title="总体思路"></a>总体思路</h3><p><strong>强调：单词永远是最重要的，手法和技巧只是辅助的工具。如果没有单词支撑，无异于浮沙高台。</strong></p><ul><li><p>从应付考研英语的角度来看，阅读新题型占大头，作文稳定分数，翻译完型下限不会低。因此优先级阅读&gt;新题型&gt;作文&gt;翻译&gt;完型</p></li><li><p>使用资料：张剑黄皮书（真题），墨墨背单词，王江涛作文</p></li></ul><p><strong>最重要的资料就是真题，请刷够两遍以上，揣摩出题人的意图和考法！！！</strong></p><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>个人思考，<strong>阅读高分 = 读懂文章+稍微拆分句子</strong></p><blockquote><p>读懂文章 首先肯定是词汇，<strong>单词背诵一定要坚持到最后一刻！！！</strong>我松懈了半个月，后期做题速度明显感觉有变慢迹象。我用墨墨，个人认为效率最高，吃饭睡前进入学习状态前皆可背。记忆的目的是单词英文和主要中文意思能一一对应，在脑袋里形成视觉记忆，<strong>不要一个单词盯着看5分钟，30s左右最长了，重在重复，而不是看一个单词的时长</strong>（重要的词注意一词多义，熟词生义，而重要的词指的是在阅读里反复出现的词，而那几个词往往就是那个意思），单词发音的话不考听力无所谓（但能读出来背诵效果肯定会好，我是把墨墨的发音调成了3次，默背效果也是可以的）。如果用墨墨简单英语和中文对应着记还是记不住就辅以墨墨的例句，加深印象。我是每个星期增加一定量的单词，循序渐进，比较符合人类学习规律。背的是5500大纲词（后来发现墨墨的词典里有分频的，用分频的背事半功倍），其实发现最后用的多的应该只有3000+词左右。英一情况可能要5500+。</p></blockquote><blockquote><p>还听了会晓艳的长难句课，目的是学会拆分句子，找问题的出题点。后来发现听完并没有很大收获，忘的也多，可能没有及时整理消化。总之就是时间投进去（听完要1个半月），效果不明显。<strong>高中本来就会拆分句子可以直接不听</strong></p></blockquote><blockquote><p>个人是没有听唐迟阅读课的，唐课大家反响都ok，身边也有听了唐英语一80+的。故不做评论。</p></blockquote><blockquote><p>阅读检验的唯一标准就是真题，真题两遍以上，刷完英二可以再刷英一，视你时间多少来定。</p></blockquote><h3 id="作文"><a href="#作文" class="headerlink" title="作文"></a>作文</h3><blockquote><p>用好王江涛的作文书，最好找专业的老师批改作文，可以是你的大学老师。</p><ul><li><p>小作文经常出的几个题型都准备一下，一定要自己写，我是买了作文答题卡限时写作文的。（小作文的时长控制可能直接决定了你英语能不能写完，有人写30min估计后面就会很赶了，写15分钟后面就会游刃有余）</p></li><li><p>大作文英语二考图表，第一段第三段可以套模版（背就完事了），中间那段就靠自己积累了。（也就是看看别人的作文描述类似话题怎么写，最好能背点句子，可以不用写）</p></li><li><p><strong>后期一定要有自己整理的大小作文的框架和笔记，政治和英语这种有背诵的科目，临考前抱抱佛脚，翻一翻可太有用了。最好整理电子版的，翻起来会非常方便</strong></p></li><li><p>请允许我感谢我大学精度老师：Thank you so much! Miss.Du.</p></li></ul></blockquote><h3 id="真题使用"><a href="#真题使用" class="headerlink" title="真题使用"></a>真题使用</h3><blockquote><p>我是先一天一篇阅读，然后一天一个新题型。（<strong>阅读精翻时间有多可以做，指不考数学的，不然不建议，投入产出比低</strong>，一个文章精翻一小时就没了）</p><p>然后二刷阅读新题型。（<strong>分析出题题型，和出题句子的文章中的位置和出题句子的出题部分</strong>）</p><p>再小作文，然后准备按话题和表格形式准备大作文。</p></blockquote><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p><strong>强调些方法和注意点：</strong></p><ul><li><p><strong>计算的基础，打草稿的规范（草稿洁癖）是数学下限的保证，每道题一定要算到最后！！！解题的技巧只是为你分数锦上添花，但想拿高分的你后期不仅基础的方法要会，速解方法也要会（平时注意积累），因为你不能保证当年的计算量有多大。</strong></p></li><li><p><strong>视频看一章做一章对应章节的习题，做对应章节习题前回顾一下这一章的基本框架和基本题型的解题手法，不让知识点混乱是你解题吸收的保障。</strong></p></li><li><p><strong>练习册上除了错的标记和自己卡壳的位置其他标记不用做，这样方便二三刷。错题归纳，我用了活页纸+夹子（活页本买不买无所谓），这样可以灵活的组建自己纸质的错题体型，方便插入体型和体型归类（这很重要）后期整理了1800，660，880，108上还有模拟卷上相似的题。</strong></p></li><li><p><strong>考的简单就考基础和细心，考的难就考计算和心态，平时练习时注重</strong></p></li></ul><p>优先级：高数&gt;线代（练习册没时间可只做高数部分）</p><p>使用资料</p><ul><li><p><strong>试卷答题卡</strong></p></li><li><p>基础：1800（中值题好，题量大），汤家凤讲义，线性代数辅导讲义（经典）</p></li><li><p>强化：660（19年的660，题目难度参差不齐），880（题型有真题味道，尤其线代部分），武忠祥高数辅导讲义（体型全），汤家凤辅导讲义，线性代数辅导讲义</p></li><li><p>冲刺：108（类似880浓缩版本，冲刺板块），真题（刷了三遍）</p></li><li><p>模拟卷：李永乐6套卷，章鱼八套卷，17年合工大超越2套，李艳芳2套（有一套只做了选择），方浩选择填空，李林6套，李林4套（挑了前两套）</p></li></ul><h3 id="从基础到上考场"><a href="#从基础到上考场" class="headerlink" title="从基础到上考场"></a>从基础到上考场</h3><p><strong>视频和练习册哪一年的无所谓，经典才是重要的。有谁能在3，5月份就知道考研动向呢？</strong></p><blockquote><ul><li>基础：<ul><li>视频：基础跟了汤家凤基础班视频，李永乐基础课视频</li><li>习题：老老实实写1800（练计算，中值题目出得好）。听完基础课可以过一遍辅导讲义中基础课提到的知识点和例题。</li></ul></li><li>强化：<ul><li>视频：强化的课程高数我是吃百家饭的人，视频的话章鱼积分部分可以，武忠祥除了中值不行其他都挺好，有个积分应用的通解听听挺好的。汤家风是中值讲得好，但速解技巧其实在课堂上就偏少了。当然也可以只跟一个老师，然后通过其他老师查漏补缺。（如果全程跟一个老师，武忠祥会是不错的选择。）线代还是李永乐。</li><li>题目21年1800的线代强化题目质量不行，被我废弃，（故1800基础全做，强化只做了高数）汤的辅导讲义后期体型和方法也不够多变，感觉不够力。线性代数辅导讲义刷了3遍。（每次看仍有新东西可以咀嚼）。我听b乎推荐，搞了本19年的660来做，发现质量参差不齐。（不太推荐）880只做了高数和线代前三章，已经觉得质量很好强推。章鱼的话推荐18讲吧（同学给我做了些题目，有些还是不错的）。</li></ul></li><li>冲刺：880和108加真题服用，真题第一遍刷了05-20的不留卷子，个人认为吃透才是重要的，没必要留到后面检验。这时刷完已经有基本的题目辨识度了，二刷的时候刷05-17年错题，并87年-04年的挑着自己不会的刷。最后再三刷87-17年错题，然后考前18-20的卷子二刷提感觉。</li><li>模拟：李永乐6套有用的大概3套这样，李林的系列最好全做，汤家凤8套当时有人说有照搬20年的迹象，我直接放弃。章鱼8套练计算和心态。李艳芳和合工大超越不用想着3小时做完，基本不可能。（题目难，质量李艳芳的高，合工大超越答案有错误，合工大共创不要做一堆问题。）<strong>模拟卷个人认为后期没有时间的话应多回归基础知识点（要留个3天这样，然后再留两天做做自己错题保持手感），而不是做一套模拟。我是吃了亏的，考前搞这些有些基础知识点都忘了。</strong></li><li>辅助视频（10分钟技巧当下饭，中午下完饭，下午整理）：b站心一学长（强推），还有b站郭伟老师….</li><li><strong>p.s考试的时候可能草稿纸只有A3大小的两张，有的老师不给换，有的老师能换但是要把你原来的收掉。</strong></li></ul></blockquote><h2 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a>专业课</h2><ul><li>使用资料：王道4书+真题，严蔚敏的《数据结构》，唐朔飞的《计算机组成原理》，汤小丹的《计算机操作系统》，谢希仁的《计算机网络》，<strong>试卷答题卡</strong></li></ul><blockquote><p>408专业课跟紧王道就够了！想冲110+的2-3遍王道书+真题应该是够了的。</p><p>第一轮：想考浙大的朋友可以先看啃4本经典教材，。第一轮可以先王道视频，然后教科书籍对应章节，然后王道书知识加课后习题为一个周期。一个科目大概一个月左右。</p><p>第二轮：教材拿来补漏时翻翻，然后直接王道书+错的课后习题，这时视频作为实在理解不了并且有讲到对应知识点时再去补，周期为15-20天一个科目。</p><p>第三轮：直接王道书重要常考章节+所有错的课后习题。</p><p>真题：用对应的答题卡限时做，对应的常见错误用电子笔记记下，提醒自己每次规范处理。因为408可以出的题型实在是太多了。出成什么样都不为过。</p></blockquote><h2 id="复试"><a href="#复试" class="headerlink" title="复试"></a>复试</h2><ul><li>等已经开始读研了再更吧，有想了解的私信。</li></ul><blockquote><p>有反复思考为什么我能上岸，审视自己无不如临深渊，如履薄冰。惊觉我能上岸并非全是个人努力，很大程度上也是基于身边朋友和老师的无私帮助，亲朋好友的鼓励。每每想到此无不感动至极，也想把这份感动传承下去，帮助到更多的人，如果看到这有所帮助，我亦不胜感激！</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;抱着想写点什么记录考研的心态，也应某朋友的要求写下这个经验贴。&lt;/p&gt;
&lt;p&gt;看完不求点赞转发，如果能从我的经历中获得什么，我会感到开心和欣慰。&lt;/p&gt;</summary>
    
    
    
    <category term="考研" scheme="https://csberlin.github.io/categories/%E8%80%83%E7%A0%94/"/>
    
    
    <category term="考研" scheme="https://csberlin.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>三毛</title>
    <link href="https://csberlin.github.io/2021/04/23/%E4%B8%89%E6%AF%9B/"/>
    <id>https://csberlin.github.io/2021/04/23/%E4%B8%89%E6%AF%9B/</id>
    <published>2021-04-23T03:06:49.000Z</published>
    <updated>2021-05-05T02:17:14.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="雨季不再来"><a href="#雨季不再来" class="headerlink" title="雨季不再来"></a>雨季不再来</h1><blockquote><p>感叹与才华横溢，涉猎广泛，亦感叹于悲苦，抑郁童少年，从沉沦到蜕变，又惊觉于古灵精怪，感同深受的细腻情怀。真有血有肉有灵气不同于流俗之人也！</p></blockquote><span id="more"></span><h2 id="当三毛还是二毛的时候"><a href="#当三毛还是二毛的时候" class="headerlink" title="当三毛还是二毛的时候"></a>当三毛还是二毛的时候</h2><blockquote><p>我的心境，已如渺渺清空，浩浩大海，平静，安详，淡泊。对人处事我并不天真，但我依旧看不起油滑；我不偏激，我甚而对每一个人心存感激，因为生活是人群共同建立的，没有他人，也不可能有我。</p></blockquote><blockquote><p>《雨季不再来》是我一个生命阶段，是我无可否认亦躲藏不了的过去。它好，它不好，都是造就成今日健康三毛的基石。也就如一块衣料一样，它可能用旧了，会有陈旧的风华，而它的质地，却仍是当初纺织机上织出来的经纬</p></blockquote><blockquote><p>人之所以悲哀，是因为我们留不住岁月，更无法不承认，青春，有一日是要那么自然地消逝过去。</p></blockquote><blockquote><p>而人之可贵，也在于我们因着时光环境的改变，在生活上得到长进。岁月的流失固然是无可奈何，而人的逐渐蜕变，却又超脱不出时光的力量</p></blockquote><h2 id="惑"><a href="#惑" class="headerlink" title="惑"></a>惑</h2><blockquote><p>我从哪里来，没有人知道，我去的地方……人人都要去，风呼呼地吹，水哗哗地流，我去的地方……人人都…… -《珍妮的画像》</p></blockquote><h2 id="蓦然回首"><a href="#蓦然回首" class="headerlink" title="蓦然回首"></a>蓦然回首</h2><blockquote><p>短短的路，一切寂静，好似永远没有尽头，而我，一步一步将自己踩回了少年</p></blockquote><blockquote><p>就这一步，二十年的光阴飞逝，心中如电如幻如梦，流去的岁月了无痕迹，而我，跌进了时光的隧道里，又变回了那年冬天的孩子-情怯依旧</p></blockquote><h2 id="逃学为读书"><a href="#逃学为读书" class="headerlink" title="逃学为读书"></a>逃学为读书</h2><blockquote><p>我所居兮，青埂之峰，我所游兮，鸿濛太空，谁与我逝兮，吾谁与从？渺渺茫茫兮，归彼大荒！ - 《红楼梦》</p></blockquote><blockquote><p>在象牙塔里看书，实在是急不得的，一旦机缘和功力到了某个程度，这个围住人的塔会自然而然地消失，而“真理”，就那么明明白白，简简单单地向人呈现了。</p></blockquote><h2 id="雨季不再来-1"><a href="#雨季不再来-1" class="headerlink" title="雨季不再来"></a>雨季不再来</h2><blockquote><p>总有一日，我要在一个充满阳光的早晨醒来，我会穿着那双清洁干燥的黄球鞋，踏上一条充满日光的大道。那时候，我会说，看这阳光，雨季不再来。</p></blockquote><h2 id="秋恋"><a href="#秋恋" class="headerlink" title="秋恋"></a>秋恋</h2><blockquote><p>因为爱的遗赠是羞怯的，他说不出名字来，它掠过阴翳，把片片欢乐铺展在尘埃上，捕捉它，否则却永远失去 -泰戈尔</p></blockquote><h2 id="西风不识相"><a href="#西风不识相" class="headerlink" title="西风不识相"></a>西风不识相</h2><blockquote><p>国民外交固然重要，但是在建交之前，绝不可过敏跌跤。那样出了受人欺负之外，建立的邦交也是没有尊严的。</p></blockquote><blockquote><p>我那时候才又明白了一个道理，对洋鬼子可以不忍，对自己同胞，可要百忍。</p></blockquote><h2 id="月河"><a href="#月河" class="headerlink" title="月河"></a>月河</h2><blockquote><p>人生岁月尔尔，在平淡中能寻几丝欢乐，半段回忆，也是可调遣你半生的了。<br>生活实在不易，而人又要为这些事情劳苦终日，终年，甚至终其一生的岁月……</p></blockquote><h2 id="我从台湾起飞"><a href="#我从台湾起飞" class="headerlink" title="我从台湾起飞"></a>我从台湾起飞</h2><blockquote><p>你想有益于社会，最好的法子，莫如把你自己这块材料铸成器。</p></blockquote><blockquote><p>“你知道这世界上有一种人，他们是永远没有假期，没有太多的家庭生活，没有悠闲的时间，也永远不许疲倦。像一条驴子一样竟日工作，出卖心力，劳力的，这种人就是生意人。有时候，我为自己目前的成绩感到安慰，但是我常常自问，我为了什么这样劳碌？我的一生就要如此度过吗？”</p></blockquote><h2 id="去年的冬天"><a href="#去年的冬天" class="headerlink" title="去年的冬天"></a>去年的冬天</h2><blockquote><p>我一面站在车内向他们挥手，也再度保住了自己的幸福一般，而幸福是那么的遥不可及，就如同永远等待不到的青鸟一样。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;雨季不再来&quot;&gt;&lt;a href=&quot;#雨季不再来&quot; class=&quot;headerlink&quot; title=&quot;雨季不再来&quot;&gt;&lt;/a&gt;雨季不再来&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;感叹与才华横溢，涉猎广泛，亦感叹于悲苦，抑郁童少年，从沉沦到蜕变，又惊觉于古灵精怪，感同深受的细腻情怀。真有血有肉有灵气不同于流俗之人也！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="文学" scheme="https://csberlin.github.io/categories/%E6%96%87%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode18</title>
    <link href="https://csberlin.github.io/2021/04/20/leetcode18/"/>
    <id>https://csberlin.github.io/2021/04/20/leetcode18/</id>
    <published>2021-04-20T08:55:20.000Z</published>
    <updated>2021-05-05T02:09:17.732Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://csberlin.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode15</title>
    <link href="https://csberlin.github.io/2021/04/18/leetcode15/"/>
    <id>https://csberlin.github.io/2021/04/18/leetcode15/</id>
    <published>2021-04-18T14:37:33.000Z</published>
    <updated>2021-05-05T02:31:01.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个包含 n 个整数的数组&nbsp;nums，判断&nbsp;nums&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。</p><span id="more"></span><p>相似题leetcode1</p><h1 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>nums = [-1,0,1,2,-1,-4]</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>[[-1,-1,2],[-1,0,1]]</p><h1 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h1><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>nums = []</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>[]</p><h1 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h1><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>nums = [0]</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>[]</p><h1 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h1><ul><li>暴力 三个for</li><li>双指针 <ul><li>每次i,j,k循环进行搜索前，要进行去重操作</li><li>i,j,k 固定i值，右侧j为最左开始的指针，k为从最右测开始的指针</li></ul></li></ul><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> k=len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;++j)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[i]+nums[j]+nums[k]&gt;target)</span><br><span class="line">                    --k;</span><br><span class="line">                <span class="keyword">if</span>(j==k) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]==target)</span><br><span class="line">                    ans.<span class="built_in">push_back</span>({nums[i],nums[j],nums[k]});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; i++) {</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">int</span> L = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R){</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>){</span><br><span class="line">                    ans.<span class="built_in">push_back</span>({nums[i],nums[L],nums[R]});</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[++L]); <span class="comment">//去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[--R]); <span class="comment">//去重</span></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">            }</span><br><span class="line">        }        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h1><p>排序后，对有序数组的元素进行哈希表存储，哈希表值存储有序数组的下标<br>我们首先通过两层遍历，确定好前两位数字，那么我们只需要哈希表是否存在符合情况的第三位数字即可，跟暴力解法的思路类似，很容易理解，但是这里我们需要注意的情况就是，例如我们的例子为[-2 , 1 , 1],如果我们完全按照以上思路来的话，则会出现两个解，[-2 , 1 , 1]和[1 , 1, -2]。具体原因，确定 -2，1之后发现 1 在哈希表中，存入。确定 1 ，1 之后发现 -2 在哈希表中，存入。所以我们需要加入一个约束避免这种情况，那就是我们第三个数的索引大于第二个数时才存入。</p><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{<span class="comment">//网上一个老哥的题解</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) {</span><br><span class="line">       <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>){</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">//排序</span></span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; resultarr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="comment">//存入哈希表</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++){</span><br><span class="line">           map.put(nums[i],i);</span><br><span class="line">       }</span><br><span class="line">       Integer t;</span><br><span class="line">       <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i){            </span><br><span class="line">            target = -nums[i];</span><br><span class="line">            <span class="comment">//去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]){</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; ++j){</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j-<span class="number">1</span>]){</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }             </span><br><span class="line">                <span class="keyword">if</span>((t = map.get(target - nums[j])) != <span class="keyword">null</span>){</span><br><span class="line">                    <span class="comment">//符合要求的情况,存入</span></span><br><span class="line">                    <span class="keyword">if</span>(t &gt; j){                      </span><br><span class="line">                       resultarr.add(<span class="keyword">new</span> ArrayList&lt;&gt;</span><br><span class="line">                       (Arrays.asList(nums[i], nums[j], nums[t])));</span><br><span class="line"></span><br><span class="line">                    } </span><br><span class="line">                    <span class="keyword">else</span>{</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }                                                  </span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> resultarr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个包含 n 个整数的数组&amp;nbsp;nums，判断&amp;nbsp;nums&amp;nbsp;中是否存在三个元素 a，b，c ，使得&amp;nbsp;a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。&lt;br&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://csberlin.github.io/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="https://csberlin.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="求和，哈希表" scheme="https://csberlin.github.io/tags/%E6%B1%82%E5%92%8C%EF%BC%8C%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1</title>
    <link href="https://csberlin.github.io/2021/04/18/leetcode1/"/>
    <id>https://csberlin.github.io/2021/04/18/leetcode1/</id>
    <published>2021-04-18T13:56:04.000Z</published>
    <updated>2021-05-05T02:40:14.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 nums&nbsp;和一个整数目标值 target，请你在该数组中找出 和为目标值 的那&nbsp;两个&nbsp;整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p><span id="more"></span><h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>nums = [2,7,11,15], target = 9</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>[0,1]</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h1><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>nums = [3,2,4], target = 6</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>[1,2]</p><h1 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h1><p>暴力</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    <span class="comment">// （能写++i就写++i，把变量能放在循环外面就放外面）</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) {</span><br><span class="line">                <span class="keyword">return</span> {i, j};</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> {};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h1><p>unordered_map模拟哈希表，哈希表内存储元素次序</p><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash_map;</span><br><span class="line">    <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> it = hash_map.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(it!=hash_map.<span class="built_in">end</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> {it-&gt;second,i};</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            hash_map[nums[i]] = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> {};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个整数数组 nums&amp;nbsp;和一个整数目标值 target，请你在该数组中找出 和为目标值 的那&amp;nbsp;两个&amp;nbsp;整数，并返回它们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;br&gt;你可以按任意顺序返回答案。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://csberlin.github.io/categories/leetcode/"/>
    
    
    <category term="哈希表，双指针" scheme="https://csberlin.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="求和" scheme="https://csberlin.github.io/tags/%E6%B1%82%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>深度学习3-卷积</title>
    <link href="https://csberlin.github.io/2021/04/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A03-%E5%8D%B7%E7%A7%AF/"/>
    <id>https://csberlin.github.io/2021/04/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A03-%E5%8D%B7%E7%A7%AF/</id>
    <published>2021-04-18T13:56:04.000Z</published>
    <updated>2021-05-05T02:38:52.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全连接网络"><a href="#全连接网络" class="headerlink" title="全连接网络"></a>全连接网络</h1><ul><li><p>缺点：层与层之间参数过多，计算量大，内存有限</p><h1 id="卷积定义"><a href="#卷积定义" class="headerlink" title="卷积定义"></a>卷积定义</h1></li><li><p>最早在信号处理里提出（对应元素相乘后求和）</p><span id="more"></span></li><li><p>连续函数 (先将函数$g(x)$进行对$y$轴反转，为$g(-x)$然后平移n个单位n每次增加)</p><ul><li>$y[n]=\int^{+\infty}_{-\infty}{f(x)}{g(n-x)}dx$</li></ul></li><li><p>离散函数(g函数相当于核函数，即滤波器)</p><ul><li>$y[n]=\displaystyle\sum_{m={-\infty}}^{+\infty}f(m)g(n-m)$</li></ul></li></ul><h1 id="卷积网络"><a href="#卷积网络" class="headerlink" title="卷积网络"></a>卷积网络</h1><ul><li><p>对维度高的特征进行压缩提取，并且大大降低特征维度</p></li><li><p>二维：shape计算</p><ul><li>${n_{out} = {[\frac{n_{in}+2p-f}{s}+1]}}$<ul><li>$n_{in}为输入尺寸，p为padding层数，f为卷积核大小，s为步长$</li></ul></li></ul></li><li><p>二维channel=总共有多少个filter（卷积核）</p></li><li><p>三维卷积（<strong>输出一下三维卷积和多通道卷积的网络参数个数</strong>）</p><ul><li>多了深度通道，<strong>这个深度可能是视频上的连续帧</strong>，也可能是<strong>立体图像中的不同切片</strong></li></ul></li><li><p>多通道卷积（没特殊强调都是多通道卷积）</p><ul><li>多通道卷积<strong>不同的通道上的卷积核的参数是不同的</strong>，而3D卷积则由于卷积核本身是3D的，所以这个由于“深度”造成的看似不同通道上用的就是同一个卷积，权重共享。</li></ul></li><li><p>共享权重和连接</p><ul><li>对于同一个通道（对应一个卷积核）权重和偏置是共享的</li><li>如二维：对于同一个5 * 5的卷积核，共有25个参数，对应25条连线，则生成一个通道内共有25+1个参数，如果有6个卷积核生成6个通道，则这层卷积有（25+1）* 6个参数，但连接有(25+1) * 6 <em>(28 <em>28)。</em></em>可以看到多连接，少参数**</li></ul></li></ul><h1 id="空洞卷积"><a href="#空洞卷积" class="headerlink" title="空洞卷积"></a>空洞卷积</h1><ul><li><p>当网络层需要较大的感受野，但计算资源有限而无法提高卷积核数量或大小时，可以考虑空洞卷积。</p></li><li><p>Model.summary()输出</p><ul><li>(batchSize, height, width, channels)，其中None值为任意尺寸<ul><li><code>如(None, None, None, 3)</code>，允许可变图像大小。</li></ul></li></ul></li></ul><h1 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h1><ul><li>平均池化</li><li>最大池化</li><li>池化输出尺寸计算与卷积相同<ul><li>共享权重和连接<ul><li>和卷积不同，如2 * 2的池化单元，对应4条连线，但只有一个参数。一个通道共享偏置，则一个通道内共有2个参数，生成6个通道则共有2 * 6个参数。连线有（2 * 2 +1） * 6 * （14 * 14）</li></ul></li></ul></li></ul><h1 id="上采样"><a href="#上采样" class="headerlink" title="上采样"></a>上采样</h1><ul><li><p>双线性差值上采样</p><blockquote><p>单线性插值（一个方向上）就是想知道$y$对应$x$的值，已知$x_1,x_2$的$y$值可将位于$x$两侧$x_1,x_2$的点连成一条直线，来确定中间的点$x$对应的y值</p><p>双线性差值 假设我们想得到函数$f$在点$P(x,y)$的值，假设知道函数$f$在点$Q_{11}=(x_1,y_1),Q_{12}=(x_1,y_2),Q_{21}=(x_2,y_1),Q_{22}=(x_2,y_2)$的值</p><p>先在$x$方向进行差值 </p><p>$f(R_1) \approx \frac{x_2-x}{x_2-x_1}f(Q_{11})+\frac{x-x_1}{x_2-x_1}f(Q_{21}),\qquad R_1=(x,y1)$ </p><p>$f(R_2) \approx \frac{x_2-x}{x_2-x_1}f(Q_{12})+\frac{x-x_1}{x_2-x_1}f(Q_{22}),\qquad R_2=(x,y2)$</p><p>再对$y$方向进行差值</p><p>$f(P) \approx \frac{y_2-y}{y_2-y_1}f(R1)+\frac{y-y_1}{y_2-y_1}f(R_{2})$</p><p>最常见的情况，$f$就是一个像素点的像素值。</p></blockquote></li><li><p>三次内插法</p></li><li><p>Transform Conv(并非反卷积，反卷积为卷积的数学逆操作，而Transform本质仍是卷积)</p><blockquote><p>在每个像素周围补0，然后用卷积核操作得到输出</p></blockquote></li><li><p>反池化</p><blockquote><p>为了进行反池化操作，我们还需额外把（编码器中的）最大池化层的索引都存储起来(即下采样时最大池化选取值所在的位置)，用于之后（解码器中的）的反池化操作。恢复到原始尺寸，将数据映射到索引处，其它地方填充零。</p></blockquote></li></ul><blockquote><p>这样尽管会忽略邻近的信息，会丢弃大量低频信息，但是它有助于保持高频信息的完整性。</p><ol><li>减少了进行端到端训练的参数量。</li><li>对max-pooling来说，它可以提高边界的勾画，即突出高频信息。</li></ol><p>最大值相同地填充至一个区域内（上图中邻近的4格）或者做平均填充，那么不但不能准确地表示高频信息，又不能保证能够表达出低频信息，这就不如上面的做法能保证高频信息的完整性。</p></blockquote><blockquote><p> 双线性插值方法实现简单，无需训练；反卷积上采样需要训练，但能更好的还原特征图；反池化几本不用</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;全连接网络&quot;&gt;&lt;a href=&quot;#全连接网络&quot; class=&quot;headerlink&quot; title=&quot;全连接网络&quot;&gt;&lt;/a&gt;全连接网络&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;缺点：层与层之间参数过多，计算量大，内存有限&lt;/p&gt;
&lt;h1 id=&quot;卷积定义&quot;&gt;&lt;a href=&quot;#卷积定义&quot; class=&quot;headerlink&quot; title=&quot;卷积定义&quot;&gt;&lt;/a&gt;卷积定义&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最早在信号处理里提出（对应元素相乘后求和）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="DL" scheme="https://csberlin.github.io/categories/DL/"/>
    
    
    <category term="DL" scheme="https://csberlin.github.io/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>深度学习4-典型的CNN</title>
    <link href="https://csberlin.github.io/2021/04/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A04-%E5%85%B8%E5%9E%8B%E7%9A%84CNN/"/>
    <id>https://csberlin.github.io/2021/04/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A04-%E5%85%B8%E5%9E%8B%E7%9A%84CNN/</id>
    <published>2021-04-18T13:56:04.000Z</published>
    <updated>2021-05-05T02:40:45.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h1><ul><li>采用ReLU激活函数</li><li>输入尺寸固定256 * 256 ，论文处理为把长边缩放成256 然后进行256的中心裁剪</li><li>多GPU训练<ul><li>如：一个conv层要生成96个通道，可以用两个GPU分别生成48通道，提高速度</li></ul></li><li>通道交叉</li><li>局部响应归一化层（Local Response Normalization）, 后多采用批量归一化</li><li>重叠池化：相邻池化窗口之间有重叠部分<span id="more"></span></li></ul><h1 id="VGG16"><a href="#VGG16" class="headerlink" title="VGG16"></a>VGG16</h1><ul><li><p>都采用3 * 3 （代替5 * 5），效果一致，还可降低参数数目和计算量</p><blockquote><p>堆叠含有小尺寸卷积核的卷积层来代替具有大尺寸的卷积核的卷积层，并且能够使得感受野大小不变，而且多个3x3的卷积核比一个大尺寸卷积核有更多的非线性（每个堆叠的卷积层中都包含激活函数），使得decision function更加具有判别性。</p><ul><li><p>5 * 5的卷积核对其卷积，步长为1，得到的结果 (32-5)/1+1=28</p></li><li><p>第一层3 * 3：得到的结果是(32-3)/1+1=30</p><p>第二层3 * 3：得到的结果是(30-3)/1+1=28</p></li></ul></blockquote><blockquote><ul><li><p>一个5 * 5的参数量为 （5x5+output_channels(其实是偏置数量)）x output_channels ;<br>两个3 * 3的参数量为（3x3+output_channels） x output_channels*2 ;</p></li><li><p>一个5 * 5的计算量为 （5x5) x ouput_channels x output_height x output_width</p><p>两个3 * 3的计算量为 （3x3）x output_channels x output_height x output_height x 2 </p></li></ul><p>2个33等于一个55，同理3个33等于一个77</p></blockquote></li><li><p>卷积组（卷积+卷积+池化或者 卷积+卷积+卷积+池化）</p></li></ul><h1 id="GoogleNet"><a href="#GoogleNet" class="headerlink" title="GoogleNet"></a>GoogleNet</h1><ul><li><p>组成卷积模块（Inception Module)，module之间级联</p><ul><li>模块内通过做不同次数和大小的卷积可以在模块内获得不同的深浅信息</li><li>在不同模块处理后输出</li></ul></li><li><p>使用1 * 1卷积，减少权重数量，增加通道数，减少计算量。使得网络虽然变深，但参数和计算量并没有增长过快</p><blockquote><p>假设输入28 * 28 * 192，输出为28 * 28 * 32</p><ol><li><p>使用32个5 * 5 * 192的卷积核卷积</p></li><li><p>先使用16个1 * 1卷积核对输入卷积，输出28 * 28 * 16，然后再用32个5 * 5  * 16进行卷积，输出28 * 28 * 32</p></li></ol><ul><li>直接5 * 5参数量为5 * 5 * 192 * 32，计算量为 5 * 5 * 192  * 28 * 28 * 32 </li><li>先1 * 1后5 * 5  参数量为 1 * 1 * 192  * 16 + 5 * 5 * 16 * 32，计算量为 1 * 1 * 192 * 28 *28 * 16 + 5  *  5  *  16  *  28 * 28 * 32 </li></ul></blockquote></li></ul><h1 id="ResNet（18，34，50，152）"><a href="#ResNet（18，34，50，152）" class="headerlink" title="ResNet（18，34，50，152）"></a>ResNet（18，34，50，152）</h1><ul><li><h2 id="残差块（圆圈-号为通道的连接）"><a href="#残差块（圆圈-号为通道的连接）" class="headerlink" title="残差块（圆圈+号为通道的连接）"></a>残差块（圆圈+号为通道的连接）</h2></li></ul><h1 id="DenseNet"><a href="#DenseNet" class="headerlink" title="DenseNet"></a>DenseNet</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AlexNet&quot;&gt;&lt;a href=&quot;#AlexNet&quot; class=&quot;headerlink&quot; title=&quot;AlexNet&quot;&gt;&lt;/a&gt;AlexNet&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;采用ReLU激活函数&lt;/li&gt;
&lt;li&gt;输入尺寸固定256 * 256 ，论文处理为把长边缩放成256 然后进行256的中心裁剪&lt;/li&gt;
&lt;li&gt;多GPU训练&lt;ul&gt;
&lt;li&gt;如：一个conv层要生成96个通道，可以用两个GPU分别生成48通道，提高速度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通道交叉&lt;/li&gt;
&lt;li&gt;局部响应归一化层（Local Response Normalization）, 后多采用批量归一化&lt;/li&gt;
&lt;li&gt;重叠池化：相邻池化窗口之间有重叠部分&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="DL" scheme="https://csberlin.github.io/categories/DL/"/>
    
    
    <category term="DL" scheme="https://csberlin.github.io/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>leetcode88</title>
    <link href="https://csberlin.github.io/2021/04/10/leetcode88/"/>
    <id>https://csberlin.github.io/2021/04/10/leetcode88/</id>
    <published>2021-04-10T11:05:05.000Z</published>
    <updated>2021-05-05T02:33:30.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你两个有序整数数组&nbsp;nums1 和 nums2，请你将 nums2 合并到&nbsp;nums1&nbsp;中，使 nums1 成为一个有序数组。</p><p>初始化&nbsp;nums1 和 nums2 的元素数量分别为&nbsp;m 和 n 。你可以假设&nbsp;nums1 的空间大小等于&nbsp;m + n，这样它就有足够的空间保存来自 nums2 的元素。</p><span id="more"></span><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>[1,2,2,3,5,6]</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>nums1 = [1], m = 1, nums2 = [], n = 0</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>[1]</p><h1 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h1><p>常规合并</p><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">       <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> sorted[m + n];</span><br><span class="line">       <span class="keyword">int</span> cur;</span><br><span class="line">       <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) {</span><br><span class="line">           <span class="keyword">if</span> (p1 == m) {</span><br><span class="line">               cur = nums2[p2++];</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) {</span><br><span class="line">               cur = nums1[p1++];</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) {</span><br><span class="line">               cur = nums1[p1++];</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               cur = nums2[p2++];</span><br><span class="line">           }</span><br><span class="line">           sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != m + n; ++i) {</span><br><span class="line">           nums1[i] = sorted[i];</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h1 id="解题思路2（看完题解才知道）"><a href="#解题思路2（看完题解才知道）" class="headerlink" title="解题思路2（看完题解才知道）"></a>解题思路2（看完题解才知道）</h1><p>nums1的后半部分是空的，可以直接覆盖而不会影响结果。因此可以指针设置为从后向前遍历，每次取两者之中的较大者放进nums1的最后面。</p><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="number">-1</span>) {</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">-1</span>) {</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) {</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            }</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你两个有序整数数组&amp;nbsp;nums1 和 nums2，请你将 nums2 合并到&amp;nbsp;nums1&amp;nbsp;中，使 nums1 成为一个有序数组。&lt;/p&gt;
&lt;p&gt;初始化&amp;nbsp;nums1 和 nums2 的元素数量分别为&amp;nbsp;m 和 n 。你可以假设&amp;nbsp;nums1 的空间大小等于&amp;nbsp;m + n，这样它就有足够的空间保存来自 nums2 的元素。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://csberlin.github.io/categories/leetcode/"/>
    
    
    <category term="归并" scheme="https://csberlin.github.io/tags/%E5%BD%92%E5%B9%B6/"/>
    
    <category term="逆双指针" scheme="https://csberlin.github.io/tags/%E9%80%86%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode154</title>
    <link href="https://csberlin.github.io/2021/04/10/leetcode154/"/>
    <id>https://csberlin.github.io/2021/04/10/leetcode154/</id>
    <published>2021-04-10T08:38:45.000Z</published>
    <updated>2021-05-05T02:35:13.999Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]<br>若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p></li></ul><p>给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><span id="more"></span><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>nums = [1,3,5]</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>1</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>nums = [2,2,2,0,1]</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>0</p><h1 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h1><p>暴力</p><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>]) <span class="keyword">return</span> nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h1><p>二分查找 在nums[mid]==nums[high]时无法判读最小值在左半区间还是右半区间</p><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,mid,high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        {</span><br><span class="line">            mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[high]) high = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[high])low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> --high;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：&lt;br&gt;若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]&lt;br&gt;若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]&lt;br&gt;注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://csberlin.github.io/categories/leetcode/"/>
    
    
    <category term="查找" scheme="https://csberlin.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
    <category term="二分查找" scheme="https://csberlin.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode153</title>
    <link href="https://csberlin.github.io/2021/04/09/leetcode153/"/>
    <id>https://csberlin.github.io/2021/04/09/leetcode153/</id>
    <published>2021-04-09T03:04:07.000Z</published>
    <updated>2021-05-05T02:34:39.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p><p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p><span id="more"></span><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>nums = [3,4,5,1,2]</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>1</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>nums = [11,13,15,17]</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>11</p><h2 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h2><p>原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</p><h1 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h1><p>暴力</p><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//78% 39.35%</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>])</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h1><p>二分查找 保证最小值在区间[low,high]之间 可以以值画图模拟<br>二分查找写法区别：</p><ul><li>low&lt;=high low=mid+1,high=mid-1 判断时加nums[mid]==target判断（左中右）</li><li>low &lt; high low=mid,high=mid-1或者low=mid+1,high=mid  两边夹出结果（左右）</li></ul><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/</a></p><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,mid,high = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        {</span><br><span class="line">            mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[high])</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：&lt;br&gt;若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]&lt;br&gt;若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]&lt;br&gt;注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。&lt;/p&gt;
&lt;p&gt;给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://csberlin.github.io/categories/leetcode/"/>
    
    
    <category term="查找" scheme="https://csberlin.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
    <category term="二分查找" scheme="https://csberlin.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>leetcode111</title>
    <link href="https://csberlin.github.io/2021/04/08/leetcode111/"/>
    <id>https://csberlin.github.io/2021/04/08/leetcode111/</id>
    <published>2021-04-08T07:26:42.000Z</published>
    <updated>2021-05-05T02:33:59.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明：叶子节点是指没有子节点的节点。</p><span id="more"></span><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>root = [3,9,20,null,null,15,7]</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>2</p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>root = [2,null,3,null,4,null,5,null,6]</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>5</p><h1 id="解题思路1-深搜"><a href="#解题思路1-深搜" class="headerlink" title="解题思路1: 深搜"></a>解题思路1: 深搜</h1><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="解题思路2-宽搜"><a href="#解题思路2-宽搜" class="headerlink" title="解题思路2: 宽搜"></a>解题思路2: 宽搜</h1><h1 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> deep=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">bfs</span>(root,deep);</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;deep)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* end=root;</span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            TreeNode* p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left==<span class="literal">NULL</span>&amp;&amp;p-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                deep=level;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left){q.<span class="built_in">push</span>(p-&gt;left);}</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right){q.<span class="built_in">push</span>(p-&gt;right);}</span><br><span class="line">            <span class="keyword">if</span>(p==end)</span><br><span class="line">            {</span><br><span class="line">                end = q.<span class="built_in">back</span>();</span><br><span class="line">                level++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;br&gt;最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;br&gt;说明：叶子节点是指没有子节点的节点。&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://csberlin.github.io/categories/leetcode/"/>
    
    
    <category term="深搜" scheme="https://csberlin.github.io/tags/%E6%B7%B1%E6%90%9C/"/>
    
    <category term="宽搜" scheme="https://csberlin.github.io/tags/%E5%AE%BD%E6%90%9C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode26</title>
    <link href="https://csberlin.github.io/2021/04/08/leetcode26/"/>
    <id>https://csberlin.github.io/2021/04/08/leetcode26/</id>
    <published>2021-04-08T03:38:41.000Z</published>
    <updated>2021-05-05T02:32:09.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。nums 已按升序排列</p><span id="more"></span><h1 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h1><p>自己写的一个模拟删除过程，维护一个计数器够数了就减</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[j]==nums[j<span class="number">-1</span>])</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cnt=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">2</span>)</span><br><span class="line">            {</span><br><span class="line">                nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>()+j);</span><br><span class="line">                len--,j--,cnt--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h1><p>看完leetcode官方双指针后写的C++版本，但是还是干不过你们<br><img src="https://pic.leetcode-cn.com/1617850114-hzBzol-%E6%88%AA%E5%B1%8F2021-04-08%20%E4%B8%8A%E5%8D%8810.48.20.png" alt="截屏2021-04-08 上午10.48.20.png"></p><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i])</span><br><span class="line">            {</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。nums 已按升序排列&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://csberlin.github.io/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="https://csberlin.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode80</title>
    <link href="https://csberlin.github.io/2021/04/08/leetcode80/"/>
    <id>https://csberlin.github.io/2021/04/08/leetcode80/</id>
    <published>2021-04-08T03:38:41.000Z</published>
    <updated>2021-05-05T02:32:49.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。<br>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。nums 升序</p><span id="more"></span><h1 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h1><p>自己写的一个模拟删除过程，维护一个计数器够数了就减</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">            {</span><br><span class="line">                cnt++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                cnt=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">3</span>)</span><br><span class="line">            {</span><br><span class="line">                nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>()+i);</span><br><span class="line">                cnt--;</span><br><span class="line">                len--;</span><br><span class="line">                i--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h1><ul><li><p>慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度</p></li><li><p>即 nums[left],nums[right] 表示待检查的第一个元素，nums[left−1] 为上一个应该被保留的元素所移动到的指定位置.</p></li><li><p>检查上上个应该被保留的元素 nums[left-2] 是否和当前待检查元素 nums[right] 相同。当且仅当 nums[left-2]=nums[right]时，当前待检查元素 nums[right] 不应该被保留</p></li><li><p>用left-2内的元素都已经合法，通过right与left-2的比较，表示当前的元素欲检查的元素是否需要将left指向的元素更新</p><ul><li>如果相同，right指针继续往后移，left指针不动。</li><li>如果不相同，right指针指向的值要覆盖掉left指向的值，然后他们同时往后移一步</li></ul></li></ul><h2 id="代码2-网上的双指针题解"><a href="#代码2-网上的双指针题解" class="headerlink" title="代码2(网上的双指针题解)"></a>代码2(网上的双指针题解)</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; nums.length; right++) {</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">2</span> || nums[right] != nums[left - <span class="number">2</span>])</span><br><span class="line">            nums[left++] = nums[right];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。&lt;br&gt;不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。nums 升序&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="https://csberlin.github.io/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="https://csberlin.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://csberlin.github.io/2021/02/06/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://csberlin.github.io/2021/02/06/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2021-02-06T02:14:30.950Z</published>
    <updated>2021-02-15T14:29:32.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="各种数值类型的范围"><a href="#各种数值类型的范围" class="headerlink" title="各种数值类型的范围"></a>各种数值类型的范围</h3><h3 id="常见边界情况"><a href="#常见边界情况" class="headerlink" title="常见边界情况"></a>常见边界情况</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;各种数值类型的范围&quot;&gt;&lt;a href=&quot;#各种数值类型的范围&quot; class=&quot;headerlink&quot; title=&quot;各种数值类型的范围&quot;&gt;&lt;/a&gt;各种数值类型的范围&lt;/h3&gt;&lt;h3 id=&quot;常见边界情况&quot;&gt;&lt;a href=&quot;#常见边界情况&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PAT乙级1028人口普查</title>
    <link href="https://csberlin.github.io/2021/02/05/pat%E4%B9%99%E7%BA%A71028/"/>
    <id>https://csberlin.github.io/2021/02/05/pat%E4%B9%99%E7%BA%A71028/</id>
    <published>2021-02-05T03:56:41.000Z</published>
    <updated>2021-05-05T02:37:32.905Z</updated>
    
    <content type="html"><![CDATA[<p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。<br>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p><span id="more"></span><h1 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification"></a>Input Specification</h1><p>输入在第一行给出正整数 N，取值在(0,10^5]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p><h1 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification"></a>Output Specification</h1><p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>5<br>John 2001/05/12<br>Tom 1814/09/06<br>Ann 2121/01/30<br>James 1814/09/05<br>Steve 1967/11/20</p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>3 Tom John</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>筛选合法日期后，输出合法日期数，最大最小日期的人的名称</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>未考虑边界情况 一个身份都不合理 </li><li>数组少开了个0</li></ul><h1 id="方法一（结构体存储，重写比较函数）"><a href="#方法一（结构体存储，重写比较函数）" class="headerlink" title="方法一（结构体存储，重写比较函数）"></a>方法一（结构体存储，重写比较函数）</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT乙级1028人口普查.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//错因：1、未考虑边界情况 一个身份都不合理 2、数组少开了个0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">}peo;</span><br><span class="line"></span><br><span class="line">peo persons[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge_unreasonable</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(y&gt;<span class="number">2014</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">2014</span>&amp;&amp;m&gt;<span class="number">9</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">2014</span>&amp;&amp;m==<span class="number">9</span>&amp;&amp;d&gt;<span class="number">6</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;<span class="number">1814</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1814</span>&amp;&amp;m&lt;<span class="number">9</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1814</span>&amp;&amp;m==<span class="number">9</span>&amp;&amp;d&lt;<span class="number">6</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(peo A,peo B)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(A.year!=B.year) <span class="keyword">return</span> A.year&lt;B.year;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(A.month!=B.month) <span class="keyword">return</span> A.month&lt;B.month;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> A.day&lt;B.day;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) {</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">int</span> y,m,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d/%d/%d"</span>,name,&amp;y,&amp;m,&amp;d);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="built_in">judge_unreasonable</span>(y, m, d);</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">strcpy</span>(persons[count].name, name);</span><br><span class="line">            persons[count].year = y;</span><br><span class="line">            persons[count].month = m;</span><br><span class="line">            persons[count].day = d;</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(persons, persons+count, cmp);</span><br><span class="line"><span class="comment">//    边界</span></span><br><span class="line">    <span class="keyword">if</span>(count!=<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %s"</span>,count,persons[<span class="number">0</span>].name,persons[count<span class="number">-1</span>].name);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="方法二（日期哈希）"><a href="#方法二（日期哈希）" class="headerlink" title="方法二（日期哈希）"></a>方法二（日期哈希）</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT乙级1028人口普查.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//错因：1、未考虑边界情况 一个身份都不合理 2、数组少开了个0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> MAX=<span class="number">18140906</span>,MIN=<span class="number">20140906</span>;</span><br><span class="line">    string MAX_name,MIN_name;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        string name;</span><br><span class="line">        <span class="keyword">int</span> y,m,d;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d/%d/%d"</span>,&amp;y,&amp;m,&amp;d);</span><br><span class="line">        <span class="keyword">int</span> tmp = y*<span class="number">10000</span>+m*<span class="number">100</span>+d;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (tmp&lt;=<span class="number">20140906</span>&amp;&amp;tmp&gt;=<span class="number">18140906</span>) {</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (tmp&gt;=MAX) {</span><br><span class="line">                MAX = tmp;</span><br><span class="line">                MAX_name = name;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (tmp&lt;=MIN) {</span><br><span class="line">                MIN = tmp;</span><br><span class="line">                MIN_name = name;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cnt==<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %s"</span>,cnt,MIN_name.<span class="built_in">c_str</span>(),MAX_name.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="方法三（String处理日期）"><a href="#方法三（String处理日期）" class="headerlink" title="方法三（String处理日期）"></a>方法三（String处理日期）</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT乙级1028人口普查.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//错因：1、未考虑边界情况 一个身份都不合理 2、数组少开了个0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    string MAX_name,MIN_name;</span><br><span class="line">    string MAX = <span class="string">"1814/09/06"</span>,MIN = <span class="string">"2014/09/06"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        string name,tmp;</span><br><span class="line">        cin&gt;&gt;name&gt;&gt;tmp;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (tmp&lt;=<span class="string">"2014/09/06"</span>&amp;&amp;tmp&gt;=<span class="string">"1814/09/06"</span>) {</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (tmp&gt;=MAX) {</span><br><span class="line">                MAX = tmp;</span><br><span class="line">                MAX_name = name;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (tmp&lt;=MIN) {</span><br><span class="line">                MIN = tmp;</span><br><span class="line">                MIN_name = name;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cnt==<span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %s"</span>,cnt,MIN_name.<span class="built_in">c_str</span>(),MAX_name.<span class="built_in">c_str</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。&lt;br&gt;这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。&lt;/p&gt;</summary>
    
    
    
    <category term="PAT 乙级" scheme="https://csberlin.github.io/categories/PAT-%E4%B9%99%E7%BA%A7/"/>
    
    
    <category term="日期 结构体模拟" scheme="https://csberlin.github.io/tags/%E6%97%A5%E6%9C%9F-%E7%BB%93%E6%9E%84%E4%BD%93%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1009多项式相乘</title>
    <link href="https://csberlin.github.io/2021/02/05/pat%E7%94%B2%E7%BA%A71009/"/>
    <id>https://csberlin.github.io/2021/02/05/pat%E7%94%B2%E7%BA%A71009/</id>
    <published>2021-02-05T03:56:41.000Z</published>
    <updated>2021-05-05T02:36:53.220Z</updated>
    
    <content type="html"><![CDATA[<p>This time, you are supposed to find A*B where A and B are two polynomials.</p><span id="more"></span><h1 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification"></a>Input Specification</h1><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p><h1 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification"></a>Output Specification</h1><p>For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>3 3 3.6 2 6.0 1 1.6</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出两个多项式A和B，求A*B的结果</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>错因：c开了1010。应该开2000+<br>方法：用数组下标作为幂次，用数组元素存储系数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT 甲 1009多项式乘积.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//  题目链接：https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错因：c开了1010。应该开2000+</span></span><br><span class="line"><span class="comment">// 方法：用数组下标作为幂次，用数组元素存储系数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">double</span> b[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">double</span> c[<span class="number">2010</span>]={<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> K1,K2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K1);</span><br><span class="line">    <span class="keyword">while</span> (K1--) {</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> A;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;N,&amp;A);</span><br><span class="line">        a[N] = A;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K2);</span><br><span class="line">    <span class="keyword">while</span> (K2--) {</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> B;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;N,&amp;B);</span><br><span class="line">        b[N] = B;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1010</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a[i]!=<span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1010</span>; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(b[j]!=<span class="number">0</span>) {c[i+j] += a[i]*b[j];}</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2010</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span>(c[i]!=<span class="number">0</span>) count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2010</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (c[i]!=<span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d %.1lf"</span>,i,c[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;This time, you are supposed to find A*B where A and B are two polynomials.&lt;/p&gt;</summary>
    
    
    
    <category term="PAT 甲级" scheme="https://csberlin.github.io/categories/PAT-%E7%94%B2%E7%BA%A7/"/>
    
    
    <category term="多项式" scheme="https://csberlin.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙级1031查验身份证</title>
    <link href="https://csberlin.github.io/2021/02/01/pat%E4%B9%99%E7%BA%A71031/"/>
    <id>https://csberlin.github.io/2021/02/01/pat%E4%B9%99%E7%BA%A71031/</id>
    <published>2021-02-01T03:56:41.000Z</published>
    <updated>2021-05-05T02:38:21.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：<br>首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：  </p><span id="more"></span><p>Z：0 1 2 3 4 5 6 7 8 9 10<br>M：1 0 X 9 8 7 6 5 4 3 2</p><p>现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。</p><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><p>按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。</p><h2 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h2><p>4<br>320124198808240056<br>12010X198901011234<br>110108196711301866<br>37070419881216001X</p><h2 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h2><p>12010X198901011234<br>110108196711301866<br>37070419881216001X</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先用int数组存权重，用string存校验码，如果身份证非纯数字则输出，如果身份证前17位权重%11不等于最后Z对应的M值则输出。若全部身份证符合要求，则输出All passed。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>数字字符向数字的转换  数字字符-‘0’=数字</li></ul><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> quan[<span class="number">17</span>] = {<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>};</span><br><span class="line">    string jiaoyan = <span class="string">"10X98765432"</span>;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N; i++)</span><br><span class="line">    {</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">17</span>;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(s[j]&lt;<span class="string">'0'</span>||s[j]&gt;<span class="string">'9'</span>) {cout&lt;&lt;s&lt;&lt;endl;flag=<span class="literal">true</span>;<span class="keyword">break</span>;}</span><br><span class="line">            sum += (s[j]-<span class="string">'0'</span>)*quan[j];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>&amp;&amp;jiaoyan[sum%<span class="number">11</span>]!=s[<span class="number">17</span>]){cout&lt;&lt;s&lt;&lt;endl;flag=<span class="literal">true</span>;}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>) cout&lt;&lt;<span class="string">"All passed"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：&lt;br&gt;首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：  &lt;/p&gt;</summary>
    
    
    
    <category term="PAT 乙级" scheme="https://csberlin.github.io/categories/PAT-%E4%B9%99%E7%BA%A7/"/>
    
    
    <category term="字符串" scheme="https://csberlin.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1006</title>
    <link href="https://csberlin.github.io/2021/02/01/pat%E7%94%B2%E7%BA%A71006/"/>
    <id>https://csberlin.github.io/2021/02/01/pat%E7%94%B2%E7%BA%A71006/</id>
    <published>2021-02-01T03:56:41.000Z</published>
    <updated>2021-05-05T02:36:26.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><p>At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.</p><span id="more"></span><h2 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h2><p>Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:</p><p>ID_number Sign_in_time Sign_out_time</p><p>where times are given in the format HH:MM:SS, and ID_number is a string with no more than 15 characters.</p><h2 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification"></a>Output Specification</h2><p>For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.</p><p>Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>SC3021234 CS301133</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>时间哈希</p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT甲级1006.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/6.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> earid[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">char</span> lateid[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> eartime = <span class="number">86400</span>;</span><br><span class="line">    <span class="keyword">int</span> latetime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"><span class="comment">//    scanf后面如果接</span></span><br><span class="line"><span class="comment">//    getchar();</span></span><br><span class="line">    <span class="keyword">while</span> (N--) {</span><br><span class="line">        <span class="keyword">int</span> h1,m1,s1,h2,m2,s2;</span><br><span class="line"><span class="comment">//        不能用gets 不然把后面的数字也读到字符数组里了</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d:%d:%d %d:%d:%d"</span>,id,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2);</span><br><span class="line">        <span class="keyword">int</span> tmp1 = <span class="number">3600</span>*h1+m1*<span class="number">60</span>+s1;</span><br><span class="line">        <span class="keyword">int</span> tmp2 = <span class="number">3600</span>*h2+m2*<span class="number">60</span>+s2;</span><br><span class="line">        <span class="keyword">if</span>(tmp1&lt;eartime) {eartime = tmp1;<span class="built_in">strcpy</span>(earid,id);}</span><br><span class="line">        <span class="keyword">if</span>(tmp2&gt;latetime) {latetime = tmp2;<span class="built_in">strcpy</span>(lateid,id);}</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %s"</span>,earid,lateid);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h1&gt;&lt;p&gt;At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day.&lt;/p&gt;</summary>
    
    
    
    <category term="PAT 甲级" scheme="https://csberlin.github.io/categories/PAT-%E7%94%B2%E7%BA%A7/"/>
    
    
    <category term="时间哈希" scheme="https://csberlin.github.io/tags/%E6%97%B6%E9%97%B4%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙级1030完美数列</title>
    <link href="https://csberlin.github.io/2021/01/25/pat%E4%B9%99%E7%BA%A71030/"/>
    <id>https://csberlin.github.io/2021/01/25/pat%E4%B9%99%E7%BA%A71030/</id>
    <published>2021-01-25T03:56:41.000Z</published>
    <updated>2021-05-05T02:37:49.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M &lt;= m * p，则称这个数列是完美数列。<br>现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。   </p><span id="more"></span><p>输入格式：<br>输入第一行给出两个正整数N和p，其中N（&lt;= 10^5）是输入的正整数的个数，p（&lt;= 10^9）是给定的参数。第二行给出N个正整数，每个数不超过10^9。<br>输出格式：<br>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p><p>输入样例：<br>10 8<br>2 3 20 4 5 1 6 7 8 9</p><p>输出样例：<br>8</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先将数列从小到大排序，设当前结果为max = 1，当前最长长度为temp = 1；从i = 0～n，j从i + max到n，【因为是为了找最大的max，所以下一次j只要从i的max个后面开始找】每次计算temp若大于max则更新max，最后输出max的值</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>m*p有可能超出int表示范围 用long long声明p</li><li>采用相当于滑动窗口的形式减少查找次数</li></ul><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示范 未考虑注意中的两点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(a, a+n);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a[i]*p &lt; a[j]) <span class="keyword">break</span>;</span><br><span class="line">            temp++;</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;max) max = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://res.cloudinary.com/dq1yc7tiz/image/upload/v1612534485/PAT%E4%B9%99%E7%BA%A7/PAT%E4%B9%99%E7%BA%A71030_%E9%94%99%E8%AF%AF_az3mma.png" alt="PAT乙级1030"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AC代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> p; <span class="comment">//long long</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(a, a+n);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1</span>,temp = <span class="number">1</span>; <span class="comment">//temp不能放进单层循环内</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+max;j&lt;n;j++) <span class="comment">//是max不是temp</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(a[i]*p &lt; a[j]) <span class="keyword">break</span>;</span><br><span class="line">            temp++;</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;max) max = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M &amp;lt;= m * p，则称这个数列是完美数列。&lt;br&gt;现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。   &lt;/p&gt;</summary>
    
    
    
    <category term="PAT 乙级" scheme="https://csberlin.github.io/categories/PAT-%E4%B9%99%E7%BA%A7/"/>
    
    
    <category term="查找" scheme="https://csberlin.github.io/tags/%E6%9F%A5%E6%89%BE/"/>
    
    <category term="滑动窗口优化" scheme="https://csberlin.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1002多项式相加</title>
    <link href="https://csberlin.github.io/2021/01/25/pat%E7%94%B2%E7%BA%A71002/"/>
    <id>https://csberlin.github.io/2021/01/25/pat%E7%94%B2%E7%BA%A71002/</id>
    <published>2021-01-25T03:56:41.000Z</published>
    <updated>2021-05-05T02:35:55.446Z</updated>
    
    <content type="html"><![CDATA[<p>This time, you are supposed to find A+B where A and B are two polynomials.</p><span id="more"></span><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5</p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>3 2 1.5 1 2.9 0 3.2</p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>计算多项式A+B的和</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>设立c数组，长度为指数的最大值，c[i] = j表示指数i的系数为j，接收a和b输入的同时将对应指数的系数加入到c中，累计c中所有非零系数的个数，然后从后往前输出所有系数不为0的指数和系数</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  PAT 甲 1002A+B多项式.cpp</span></span><br><span class="line"><span class="comment">//  Fushi</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by H C on 2021/2/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">double</span> b[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"><span class="keyword">double</span> c[<span class="number">1010</span>]={<span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> K1,K2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K1);</span><br><span class="line">    <span class="keyword">while</span> (K1--) {</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> A;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;N,&amp;A);</span><br><span class="line">        a[N] = A;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K2);</span><br><span class="line">    <span class="keyword">while</span> (K2--) {</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> B;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;N,&amp;B);</span><br><span class="line">        b[N] = B;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1010</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a[i]!=<span class="number">0</span>||b[i]!=<span class="number">0</span>) {</span><br><span class="line">            c[i] = a[i]+b[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1010</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span>(c[i]!=<span class="number">0</span>) count++;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1010</span>; i&gt;=<span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (c[i]!=<span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d %.1lf"</span>,i,c[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;This time, you are supposed to find A+B where A and B are two polynomials.&lt;/p&gt;</summary>
    
    
    
    <category term="PAT 甲级" scheme="https://csberlin.github.io/categories/PAT-%E7%94%B2%E7%BA%A7/"/>
    
    
    <category term="多项式" scheme="https://csberlin.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
</feed>
